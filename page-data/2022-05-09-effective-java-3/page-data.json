{"componentChunkName":"component---src-templates-post-jsx","path":"/2022-05-09-effective-java-3/","result":{"data":{"site":{"siteMetadata":{"title":"수학하는 개발자"}},"markdownRemark":{"id":"9f19d48e-bb0a-58e9-b29c-d423323a1b33","excerpt":"싱글턴(singleton) 객체의 인스턴스를 오직 1개만 생성할 수 있는 클래스. 생성자의 호출이 반복적으로 이뤄져도 객체는 최초 생성된 객체를 반환해준다. 클래스를 싱글턴으로 만드는 이유? 메모리 낭비를 방지할 수 있다 최초 한 번 생성하면 이후에도 고정된 메모리 영역을 사용하기 때문에 객체에 접근할 때 메모리 낭비를 방지할 수 있다. 다른 클래스 간에…","html":"<h3>싱글턴(singleton)</h3>\n<p>객체의 인스턴스를 오직 1개만 생성할 수 있는 클래스. 생성자의 호출이 반복적으로 이뤄져도 객체는 최초 생성된 객체를 반환해준다.</p>\n<h3>클래스를 싱글턴으로 만드는 이유?</h3>\n<ul>\n<li>\n<p>메모리 낭비를 방지할 수 있다</p>\n<ul>\n<li>최초 한 번 생성하면 이후에도 고정된 메모리 영역을 사용하기 때문에 객체에 접근할 때 메모리 낭비를 방지할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>다른 클래스 간에 데이터 공유가 쉽다</p>\n<ul>\n<li>싱글턴 인스턴스가 전역으로 사용되기 때문에 다른 클래스의 인스턴스들이 접근하여 사용 가능하다.</li>\n</ul>\n</li>\n</ul>\n<h3>싱글턴의 단점</h3>\n<ul>\n<li>싱글톤을 구현하는 코드 자체가 많이 필요하다</li>\n<li>\n<p>테스트하기 어렵다</p>\n<ul>\n<li>테스트를 할 때 마다 매번 인스턴스의 상태를 초기화시켜주어야 한다.</li>\n</ul>\n</li>\n<li>멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 해결해야 한다</li>\n<li>해당 싱글턴 객체를 사용하는 다른 객체 간의 결함도가 높아져 객체 지향 설계 원칙에 어긋나게 된다</li>\n<li>자식클래스를 만들 수 없다</li>\n</ul>\n<h3>싱글턴을 만드는 방식 1 - public static final 필드 방식</h3>\n<p>생성자는 <code class=\"language-text\">private</code>로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 <code class=\"language-text\">public static</code> 멤버를 <code class=\"language-text\">final</code>으로 하나 마련한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Elvis</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Elvis</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 생성자</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">leaveTheBuilding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>생성자는 <code class=\"language-text\">Elvis.INSTANCE</code>를 초기화할 때 딱 한 번 호출된다. 생성자가 <code class=\"language-text\">private</code>이므로, <code class=\"language-text\">publi</code>c이나 <code class=\"language-text\">protected</code> 생성자가 없기 때문에 <code class=\"language-text\">Elvis</code> 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 클래스가 하나인 것으로 보증된다.</p>\n<p>이렇게 만들면 간결하면서도 해당 클래스가 싱글턴임을 API에 명백하게 드러낼 수 있다.</p>\n<h3>싱글턴을 만드는 방식 2 - 정적 팩터리 방식의 싱글턴</h3>\n<p>정적 팩터리 메서드를 <code class=\"language-text\">public static</code>으로 만드는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Elvis</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Elvis</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 생성자</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Elvis</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">leaveTheBuilding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>정적 팩터리 메서드인 <code class=\"language-text\">Elvis.getInstance</code>는 항상 같은 객체의 참조를 반환하도록 되어있다. </p>\n<p>이 방식의 장점</p>\n<ul>\n<li>API를 바꾸지 않고도 싱글턴이 아닌 다른 것으로 변경할 수 있다</li>\n<li>정적팩터리를 제네릭 싱글턴 팩터리로도 만들 수 있다</li>\n<li>정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다</li>\n</ul>\n<h3>싱글턴을 만드는 방식 3 - 원소가 하나인 열거 타입 선언</h3>\n<p>public 필드 방식과 비슷하지만, 클래스를 열거 타입으로 만드는 방법이다. 싱글턴 생성 방법 중 가장 바람직한 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Elvis</span> <span class=\"token punctuation\">{</span>\n    INSTANCE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">leaveTheBuilding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방식의 장점</p>\n<ul>\n<li>더 간결하다</li>\n<li>직렬화를 간단하게 할 수 있다</li>\n</ul>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410\">이펙티브 자바</a></li>\n<li><a href=\"https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/\">싱글톤(Singleton) 패턴이란?</a></li>\n</ul>","frontmatter":{"title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라","date":"May 09, 2022","update":"May 09, 2022","tags":["Java","Effective Java"],"series":"이펙티브 자바 뽀개기"},"fields":{"slug":"/2022-05-09-effective-java-3/","readingTime":{"minutes":4.175}}},"seriesList":{"edges":[{"node":{"id":"690c77b6-8c55-52b8-a334-a43437b12181","fields":{"slug":"/2022-05-02-effective-java-1/"},"frontmatter":{"title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라"}}},{"node":{"id":"8c91a468-9765-51d6-91c0-133a46b7053c","fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라"}}},{"node":{"id":"9f19d48e-bb0a-58e9-b29c-d423323a1b33","fields":{"slug":"/2022-05-09-effective-java-3/"},"frontmatter":{"title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라"}}},{"node":{"id":"cd050bcf-7c86-5d3b-8683-bab3f5da6324","fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라"}}},{"node":{"id":"72be9954-c9b6-5c25-9a31-32d03fb85256","fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}}]},"previous":{"fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라"}},"next":{"fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라"}}},"pageContext":{"id":"9f19d48e-bb0a-58e9-b29c-d423323a1b33","series":"이펙티브 자바 뽀개기","previousPostId":"8c91a468-9765-51d6-91c0-133a46b7053c","nextPostId":"cd050bcf-7c86-5d3b-8683-bab3f5da6324"}},"staticQueryHashes":[]}