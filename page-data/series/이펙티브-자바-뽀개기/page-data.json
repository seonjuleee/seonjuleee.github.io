{"componentChunkName":"component---src-templates-series-jsx","path":"/series/이펙티브-자바-뽀개기","result":{"data":{"posts":{"nodes":[{"excerpt":"정적 팩터리 메서드 정적 팩터리 메서드(static factory method)는 클래스의 인스턴스를 반환하는 정적 메서드이다.  예를 몇 가지 들어보자.  클래스의  메서드  클래스의  메서드 두 메서드 다 반환 값이 클래스인 정적 메서드이기 때문에, 객체 생성의 역할을 할 수 있다. 그렇다면 왜 생성자 대신 정적 팩터리 메서드를 고려해야할까? 정적 팩…","fields":{"slug":"/2022-05-02-effective-java-1/"},"frontmatter":{"date":"May 02, 2022","update":"May 02, 2022","title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라","tags":["Java","Effective Java"]}},{"excerpt":"선택적 매개변수가 많을 때는 정적 팩터리 메서드와 생성자 모두 적절하게 대응하기가 힘든데, 빌더 패턴을 사용하면 해결 가능하다. 점층적 생성자 패턴(Telescoping constructor pattern) 빌더 패턴을 설명하기 전, 비교를 위해 다른 패턴들을 살펴보자. 빌더 패턴 전에는 점층적 생성자 패턴을 사용하여 이 문제를 해결했다고 한다.  클래스…","fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"date":"May 03, 2022","update":"May 03, 2022","title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라","tags":["Java","Effective Java"]}},{"excerpt":"싱글턴(singleton) 객체의 인스턴스를 오직 1개만 생성할 수 있는 클래스. 생성자의 호출이 반복적으로 이뤄져도 객체는 최초 생성된 객체를 반환해준다. 클래스를 싱글턴으로 만드는 이유? 메모리 낭비를 방지할 수 있다 최초 한 번 생성하면 이후에도 고정된 메모리 영역을 사용하기 때문에 객체에 접근할 때 메모리 낭비를 방지할 수 있다. 다른 클래스 간에…","fields":{"slug":"/2022-05-09-effective-java-3/"},"frontmatter":{"date":"May 09, 2022","update":"May 09, 2022","title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라","tags":["Java","Effective Java"]}},{"excerpt":"정적 멤버만 담은 유틸리티 클래스 정적 메서드와 정적 필드만을 담은 단순한 클래스는 다음과 같이 사용된다. 기본 타입 값이나 배열 관련 메서드 모으기 ex. ,  인터페이스를 구현하는 객체를 생성해주는 정적 메서드(또는 팩터리)를 모으기 ex.  final 클래스와 관련한 메서드 모으기 final 클래스를 상속받아 메서드에 넣을 수 없기 때문이다. 이런 …","fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"date":"May 10, 2022","update":"May 10, 2022","title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라","tags":["Java","Effective Java"]}},{"excerpt":"의존 관계 한 객체가 다른 객체를 생성하거나 메서드를 호출하면, 그 객체에 의존한다고 표현한다. 책에 예시로 나와있는  클래스는 스펠링이 맞는지 틀린지를 판단하는 클래스이기 때문에, 사전 클래스인 를 의존한다. 의존 관계를 정적 유틸리티 클래스와 싱글턴으로 구현 정적 유틸리티 클래스로 구현 싱글턴으로 구현 정적 유틸리티 클래스와 싱글턴으로 구현하게 되면,…","fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"date":"May 16, 2022","update":"May 16, 2022","title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["Java","Effective Java"]}},{"excerpt":"같은 기능의 객체를 불필요하게 만드는 것보다 재사용하는 것이 좋은데, 각각의 경우를 살펴보자. 불필요한 객체를 만드는 예 1 - 문자열 문자열에서 불필요한 객체를 만들게 되는 경우를 알아보자. 첫번째 코드는 String 객체를 계속해서 만드므로, 객체 생성이 불필요하게 될 수 있다.\n두번째 코드는 하나의 String 객체를 재사용한다.\n따라서 첫번째보다는…","fields":{"slug":"/2022-05-17-effective-java-6/"},"frontmatter":{"date":"May 17, 2022","update":"May 17, 2022","title":"[Effective Java] Item 6 - 불필요한 객체 생성을 피하라","tags":["Java","Effective Java"]}},{"excerpt":"Java의 경우, C, C++과는 달리 다 쓴 객체를 알아서 회수한다. 하지만 메모리 관리에 신경을 써야하는 몇 가지 경우가 있는데, 이러한 경우를 예시와 함께 알아보자.  1. 배열, 리스트 등으로 메모리를 관리하는 경우 책에 있는 예시인 스택 구현 코드를 보자.  메서드를 보면, 가 0일 때  객체를 생성만 하고, 빼지 않기 때문에  배열인 에 계속해…","fields":{"slug":"/2022-05-24-effective-java-7/"},"frontmatter":{"date":"May 24, 2022","update":"May 24, 2022","title":"[Effective Java] Item 7 - 다 쓴 객체 참조를 해제하라","tags":["Java","Effective Java"]}}]}},"pageContext":{"series":"이펙티브 자바 뽀개기"}},"staticQueryHashes":[]}