{"componentChunkName":"component---src-templates-post-jsx","path":"/2022-05-02-effective-java-1/","result":{"data":{"site":{"siteMetadata":{"title":"수학하는 개발자"}},"markdownRemark":{"id":"690c77b6-8c55-52b8-a334-a43437b12181","excerpt":"정적 팩터리 메서드 정적 팩터리 메서드(static factory method)는 클래스의 인스턴스를 반환하는 정적 메서드이다.  예를 몇 가지 들어보자.  클래스의  메서드  클래스의  메서드 두 메서드 다 반환 값이 클래스인 정적 메서드이기 때문에, 객체 생성의 역할을 할 수 있다. 그렇다면 왜 생성자 대신 정적 팩터리 메서드를 고려해야할까? 정적 팩…","html":"<h3>정적 팩터리 메서드</h3>\n<p>정적 팩터리 메서드(static factory method)는 <strong>클래스의 인스턴스를 반환하는 정적 메서드</strong>이다. </p>\n<p>예를 몇 가지 들어보자.</p>\n<ul>\n<li><code class=\"language-text\">Boolean</code> 클래스의 <code class=\"language-text\">valueOf</code> 메서드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">?</span> TRUE <span class=\"token operator\">:</span> FALSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">LocalTime</code> 클래스의 <code class=\"language-text\">now</code> 메서드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">LocalTime</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Clock</span><span class=\"token punctuation\">.</span><span class=\"token function\">systemDefaultZone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>두 메서드 다 반환 값이 클래스인 정적 메서드이기 때문에, 객체 생성의 역할을 할 수 있다.</p>\n<p>그렇다면 왜 생성자 대신 정적 팩터리 메서드를 고려해야할까?</p>\n<h3>정적 팩터리 메서드가 생성자보다 좋은 이유</h3>\n<h4>1. 이름을 가질 수 있다</h4>\n<p>생성자의 경우, 매개변수와 생성자 자체만으로는 반환되는 객체의 특성을 제대로 설명하지 못한다.</p>\n<p>좀 더 자세히 알아보기 위해 <strong>값이 소수인 <code class=\"language-text\">BigInteger</code>를 반환</strong>하는 예제를 각각 들어보자.</p>\n<ul>\n<li>\n<p>생성자의 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">BigInteger</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> bitLength<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Random</span> rnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>정적 팩터리 메서드의 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">BigInteger</span> <span class=\"token function\">probablePrime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> bitLength<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Random</span> rnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p>정적 팩터리 메서드는 <code class=\"language-text\">probablePrime</code>이라는 메서드 이름을 통해 반환되는 객체의 의미를 좀 더 명확하게 표현할 수 있다.</p>\n<h4>2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다</h4>\n<p>정적 팩터리 메서드를 사용하면, </p>\n<ul>\n<li>인스턴스를 미리 만들어 놓거나 </li>\n<li>새로 생성한 인스턴스를 캐싱하여 재활용하는\n방식으로 불필요하게 객체를 생성하는 것을 방지할 수 있다.</li>\n</ul>\n<p>대표적인 예로, <code class=\"language-text\">Boolean.valueOf(boolean)</code> 메서드는 객체를 아예 생성하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">?</span> TRUE <span class=\"token operator\">:</span> FALSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또 다른 예로 로또 번호를 생성하는 메서드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LottoNumber</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MIN_LOTTO_NUMBER <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAX_LOTTO_NUMBER <span class=\"token operator\">=</span> <span class=\"token number\">45</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">LottoNumber</span><span class=\"token punctuation\">></span></span> lottoNumberCache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">IntStream</span><span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span>MIN_LOTTO_NUMBER<span class=\"token punctuation\">,</span> MAX_LOTTO_NUMBER<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-></span> lottoNumberCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LottoNumber</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LottoNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>number <span class=\"token operator\">=</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">LottoNumber</span> <span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// LottoNumber를 반환하는 정적 팩토리 메서드</span>\n      <span class=\"token keyword\">return</span> lottoNumberCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>| 출처 <a href=\"https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C</a></p>\n<p>정적 팩터리 메서드를 통해 로또 번호 객체를 새로 생성하는 것이 아니라 캐싱을 통해서 불필요한 객체 생성을 막을 수 있다. </p>\n<p>또, 생성자의 접근 제한자를 <code class=\"language-text\">private</code>로 설정하여 객체 생성을 정적 팩터리 메서드로만 가능하게 제한할 수 있다.</p>\n<h4>3. 반환 타입의 하위 타입 객체를 반환할 수 있다</h4>\n<p><code class=\"language-text\">Coffee</code>를 상속받는 하위 클래스 <code class=\"language-text\">Americano</code>, <code class=\"language-text\">Latte</code>, <code class=\"language-text\">Espresso</code>가 있다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Coffee</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Coffee</span> <span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> ingredient<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ingredient<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"water\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Americano</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ingredient<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"milk\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Latte</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Espresso</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>정적 팩터리 메서드인 <code class=\"language-text\">of</code>에서는 재료에 따라 원하는 하위 클래스를 반환시킬 수 있다.</p>\n<p>이처럼 반환할 객체의 클래스를 자유롭게 선택할 수 있기 때문에, 굉장히 유연하게 만들 수 있다는 장점이 있다.</p>\n<h4>4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다</h4>\n<p><code class=\"language-text\">EnumSet</code> 클래스에서는, public 생성자 없이 정적 팩터리만 제공하는데, 원소의 수에 따라 두 가지 하위 클래스(<code class=\"language-text\">RegularEnumSet</code>, <code class=\"language-text\">JumboEnumSet</code>) 중 하나의 인스턴스를 반환한다.</p>\n<p><code class=\"language-text\">EnumSet</code>의 <code class=\"language-text\">noneOf</code> 메서드를 보자. 제네릭 때문에 복잡해 보이지만 밑에 if 문만 보면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Enum</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">EnumSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">noneOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> elementType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Enum</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> universe <span class=\"token operator\">=</span> <span class=\"token function\">getUniverse</span><span class=\"token punctuation\">(</span>elementType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>universe <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassCastException</span><span class=\"token punctuation\">(</span>elementType <span class=\"token operator\">+</span> <span class=\"token string\">\" not an enum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>universe<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">64</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegularEnumSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>elementType<span class=\"token punctuation\">,</span> universe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JumboEnumSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>elementType<span class=\"token punctuation\">,</span> universe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">noneOf</code> 메서드는 EnumSet을 반환하는 정적 팩터리 메서드인데, 입력 매개변수인 <code class=\"language-text\">elementType</code>에 의해 결정된 <code class=\"language-text\">universe</code>의 길이가 65를 기점으로 작으면 <code class=\"language-text\">RegularEnumSet</code>을 반환하고, 크면 <code class=\"language-text\">JumboEnumSet</code>를 반환한다.</p>\n<p>이처럼 정적 팩터리 메서드를 사용하면 입력 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다.</p>\n<h4>5. 작성 시점에 반환할 객체의 클래스가 존재하지 않아도 된다</h4>\n<h3>정적 팩터리 메서드의 단점</h3>\n<h4>1. 상속 시 정적 팩터리 메서드만 제공하면 하위클래스를 생성할 수 없다</h4>\n<p>상속을 하게 되면 public이나 protected 생성자가 필요하기 때문이다.\n그러나, 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들기 위해서는 이 제약을 지켜야하기 때문에 장점이 될 수 있다.</p>\n<h4>2. 프로그래머가 찾기 힘들다</h4>\n<p>API 설명이 명확하게 드러나지 않기 때문에 사용자가 사용하는 방식을 알아내야 한다.</p>\n<h3>정적 팩터리 메서드에서 흔하게 사용하는 네이밍 방식</h3>\n<ul>\n<li><code class=\"language-text\">from</code> : 매개변수를 하나 받아서 해당 타입의 객체 생성</li>\n<li><code class=\"language-text\">of</code> : 여러 매개변수를 받아 적합한 타입의 객체 생성</li>\n<li><code class=\"language-text\">valueOf</code> : <code class=\"language-text\">from</code>과 <code class=\"language-text\">of</code>의 더 자세한 버전</li>\n<li><code class=\"language-text\">instance | getInstance</code> : 매개변수로 명시한 인스턴스를 반환. 그러나 같은 인스턴스라는 보장 X</li>\n<li><code class=\"language-text\">create | newInstance</code> : <code class=\"language-text\">instance</code>, <code class=\"language-text\">getInstance</code>와 같지만, 매번 새로운 인스턴스를 생성해 반환</li>\n<li><code class=\"language-text\">getType | newType</code> : <code class=\"language-text\">getInstance</code>, <code class=\"language-text\">newInstance</code>와 같으나, 다른 클래스에 팩터리 메서드를 정의할 때 사용</li>\n<li><code class=\"language-text\">type</code> : <code class=\"language-text\">getType</code>과 <code class=\"language-text\">newType</code>의 간결한 버전</li>\n</ul>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410\">이펙티브 자바</a></li>\n<li><a href=\"https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">정적 팩토리 메서드는 왜 사용할까?</a></li>\n</ul>","frontmatter":{"title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라","date":"May 02, 2022","update":"May 02, 2022","tags":["Java","Effective Java"],"series":"이펙티브 자바 뽀개기"},"fields":{"slug":"/2022-05-02-effective-java-1/","readingTime":{"minutes":7.265}}},"seriesList":{"edges":[{"node":{"id":"690c77b6-8c55-52b8-a334-a43437b12181","fields":{"slug":"/2022-05-02-effective-java-1/"},"frontmatter":{"title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라"}}},{"node":{"id":"8c91a468-9765-51d6-91c0-133a46b7053c","fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라"}}},{"node":{"id":"9f19d48e-bb0a-58e9-b29c-d423323a1b33","fields":{"slug":"/2022-05-09-effective-java-3/"},"frontmatter":{"title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라"}}},{"node":{"id":"cd050bcf-7c86-5d3b-8683-bab3f5da6324","fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라"}}},{"node":{"id":"72be9954-c9b6-5c25-9a31-32d03fb85256","fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"894ed220-dda1-5115-a4bc-e5ee0915421b","fields":{"slug":"/2022-05-17-effective-java-6/"},"frontmatter":{"title":"[Effective Java] Item 6 - 불필요한 객체 생성을 피하라"}}}]},"previous":{"fields":{"slug":"/2022-05-01-weekly-report/"},"frontmatter":{"title":"4월 다섯째주 주간 회고"}},"next":{"fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라"}}},"pageContext":{"id":"690c77b6-8c55-52b8-a334-a43437b12181","series":"이펙티브 자바 뽀개기","previousPostId":"050b3474-63f5-5a85-b46f-3a6304f629d3","nextPostId":"8c91a468-9765-51d6-91c0-133a46b7053c"}},"staticQueryHashes":[]}