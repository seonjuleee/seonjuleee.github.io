{"componentChunkName":"component---src-templates-post-jsx","path":"/2022-05-17-effective-java-6/","result":{"data":{"site":{"siteMetadata":{"title":"수학하는 개발자"}},"markdownRemark":{"id":"894ed220-dda1-5115-a4bc-e5ee0915421b","excerpt":"같은 기능의 객체를 불필요하게 만드는 것보다 재사용하는 것이 좋은데, 각각의 경우를 살펴보자. 불필요한 객체를 만드는 예 1 - 문자열 문자열에서 불필요한 객체를 만들게 되는 경우를 알아보자. 첫번째 코드는 String 객체를 계속해서 만드므로, 객체 생성이 불필요하게 될 수 있다.\n두번째 코드는 하나의 String 객체를 재사용한다.\n따라서 첫번째보다는…","html":"<p>같은 기능의 객체를 불필요하게 만드는 것보다 재사용하는 것이 좋은데, 각각의 경우를 살펴보자.</p>\n<h3>불필요한 객체를 만드는 예 1 - 문자열</h3>\n<p>문자열에서 불필요한 객체를 만들게 되는 경우를 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1. String 인스턴스를 새로 생성</span>\n<span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2. 하나의 String 인스턴스를 계속해서 사용</span>\n<span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>첫번째 코드는 String 객체를 계속해서 만드므로, 객체 생성이 불필요하게 될 수 있다.\n두번째 코드는 하나의 String 객체를 재사용한다.\n따라서 첫번째보다는 두번째 방법을 사용하는 것이 좋다.</p>\n<p>이와 같이 불변 클래스에서는 생성자 대신 <a href=\"https://seonjuleee.github.io/2022-05-02-effective-java-1/\">정적 팩터리 메서드</a>를 사용하면 불필요한 객체 생성을 피할 수 있다.</p>\n<p>또 다른 예제를 보자.</p>\n<p>정규표현식을 사용하여 복잡한 문자열의 유효성을 판단하는 메서드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isRomanNumeral</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^(?=.)M*(C[MD]|D?C{0,3})\"</span>\n            <span class=\"token operator\">+</span> <span class=\"token string\">\"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">String.matches</code>을 사용하면 가장 쉽게 사용할 수 있는 방법이긴 하지만, 한 번 사용되고 버려지기 때문에 생성비용이 큰 정규표현식을 사용하기에는 성능이 좋지 않다.</p>\n<p>성능 개선을 위해 <code class=\"language-text\">Pattern</code> 인스턴스를 직접 생성해 캐싱해두고, 메서드 호출 시 이 인스턴스를 재사용하도록 하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RomanNumerals</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Pattern</span> ROMAN <span class=\"token operator\">=</span> <span class=\"token class-name\">Pattern</span><span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"^(?=.)M*(C[MD]|D?C{0,3})\"</span>\n            <span class=\"token operator\">+</span> <span class=\"token string\">\"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isRomanNumeral</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> ROMAN<span class=\"token punctuation\">.</span><span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>불필요한 객체를 만드는 예 2 - 오토박싱</h3>\n<p>먼저 오토박싱에 대해 알아보자.</p>\n<p>자바에는 기본(primitive)타입과 Wrapper 클래스가 있다.</p>\n<table>\n<thead>\n<tr>\n<th>기본 타입</th>\n<th>Wrapper 클래스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n</tbody>\n</table>\n<p>기본 타입의 데이터를 객체로 취급해야 하는 경우가 있는데 이때 Wrapper 클래스로 변환해 주면 된다. 이때 기본 타입을 Wrapper 클래스로 변환하는 과정을 <strong>박싱(Boxing)</strong>이라고 한다.\n반대로, Wrapper 클래스를 다시 기본 타입의 데이터로 꺼내 변환하는 과정을 <strong>언박싱(UnBoxing)</strong>이라고 한다.</p>\n<p>이처럼 기본 타입과 Wrapper 클래스를 자바 컴파일러가 자동으로 상호 변환해주는 기술을 <strong>오토박싱/오토언박싱</strong>이라고 한다.</p>\n<p>다시 돌아와서, 책에 있는 예시를 한 번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Long</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 메서드는 <code class=\"language-text\">sum</code>을 Wrapper 클래스인 <code class=\"language-text\">Long</code>으로 선언하였는데, for문을 돌 때는 기본 타입의 <code class=\"language-text\">long</code> 타입인 <code class=\"language-text\">i</code>를 <code class=\"language-text\">sum</code>에 더해주고 있다. </p>\n<p>그렇게 되면 <code class=\"language-text\">sum</code>에 더해지기 위해 <code class=\"language-text\">long</code> 타입을 <code class=\"language-text\">Long</code> 타입으로 변환되는 오토박싱이 이루어지고, 이 과정이 <code class=\"language-text\">Integer.MAX_VALUE</code>인 2,147,483,647번 반복되고 있다.</p>\n<p>따라서 의도치 않은 오토박싱을 피하기 위해 <code class=\"language-text\">sum</code>을 Wrapper 클래스보단 기본 타입을 사용해야한다.</p>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410\">이펙티브 자바</a></li>\n<li><a href=\"https://www.inflearn.com/course/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-1/dashboard\">이펙티브 자바 완벽 공략 1부</a></li>\n<li><a href=\"http://www.tcpschool.com/java/java_api_wrapper\">Wrapper 클래스</a></li>\n</ul>","frontmatter":{"title":"[Effective Java] Item 6 - 불필요한 객체 생성을 피하라","date":"May 17, 2022","update":"May 17, 2022","tags":["Java","Effective Java"],"series":"이펙티브 자바 뽀개기"},"fields":{"slug":"/2022-05-17-effective-java-6/","readingTime":{"minutes":4.215}}},"seriesList":{"edges":[{"node":{"id":"690c77b6-8c55-52b8-a334-a43437b12181","fields":{"slug":"/2022-05-02-effective-java-1/"},"frontmatter":{"title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라"}}},{"node":{"id":"8c91a468-9765-51d6-91c0-133a46b7053c","fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라"}}},{"node":{"id":"9f19d48e-bb0a-58e9-b29c-d423323a1b33","fields":{"slug":"/2022-05-09-effective-java-3/"},"frontmatter":{"title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라"}}},{"node":{"id":"cd050bcf-7c86-5d3b-8683-bab3f5da6324","fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라"}}},{"node":{"id":"72be9954-c9b6-5c25-9a31-32d03fb85256","fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}}},{"node":{"id":"894ed220-dda1-5115-a4bc-e5ee0915421b","fields":{"slug":"/2022-05-17-effective-java-6/"},"frontmatter":{"title":"[Effective Java] Item 6 - 불필요한 객체 생성을 피하라"}}},{"node":{"id":"cb022025-20d6-5de4-8c33-1ff906361cb7","fields":{"slug":"/2022-05-24-effective-java-7/"},"frontmatter":{"title":"[Effective Java] Item 7 - 다 쓴 객체 참조를 해제하라"}}}]},"previous":{"fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"}},"next":{"fields":{"slug":"/2022-05-24-effective-java-7/"},"frontmatter":{"title":"[Effective Java] Item 7 - 다 쓴 객체 참조를 해제하라"}}},"pageContext":{"id":"894ed220-dda1-5115-a4bc-e5ee0915421b","series":"이펙티브 자바 뽀개기","previousPostId":"72be9954-c9b6-5c25-9a31-32d03fb85256","nextPostId":"cb022025-20d6-5de4-8c33-1ff906361cb7"}},"staticQueryHashes":[]}