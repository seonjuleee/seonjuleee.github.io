{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"try-finally 닫아야 하는 자원을 자용할 경우 회수할 때 를 전통적으로 사용하곤 했다.  하지만 이 방식이라면, 자원이 둘 이상일 경우에 지저분해진다는 단점이 있다.\n또, 예외 사항이 무시되어 디버깅을 어렵게 하기도 한다. try-with-resources 앞서 설명한 문제들은 로 쉽게 해결이 가능하다.\n이 구조를 사용하기 위해서는 자원이  인터페…","fields":{"slug":"/2022-06-01-effective-java-9/"},"frontmatter":{"date":"June 01, 2022","title":"[Effective Java] Item 9 - try-finally보다는 try-with-resources를 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n### try-finally\r\n\r\n닫아야 하는 자원을 자용할 경우 회수할 때 `try-finally`를 전통적으로 사용하곤 했다. \r\n\r\n```java\r\nstatic String firstLineOfFile(String path, String defaultVal) throws IOException {\r\n    BufferedReader br = new BufferedReader(new FileReader(path));\r\n    // try-finally 방식 사용\r\n    try {\r\n        return br.readLine();\r\n    } finally {\r\n        br.close();\r\n    }\r\n}\r\n```\r\n\r\n하지만 이 방식이라면, 자원이 둘 이상일 경우에 지저분해진다는 단점이 있다.\r\n또, 예외 사항이 무시되어 디버깅을 어렵게 하기도 한다.\r\n\r\n```java\r\nstatic void copy(String src, String dst) throws IOException {\r\n    InputStream in = new FileInputStream(src);\r\n    // InputStream에 대한 try-finally 문\r\n    try {\r\n        OutputStream out = new FileOutputStream(dst);\r\n        // OutputStream에 대한 try-finally 문\r\n        try {\r\n            byte[] buf = new byte[BUFFER_SIZE];\r\n            int n;\r\n            while ((n = in.read(buf)) >= 0)\r\n                out.write(buf, 0, n);\r\n        } finally {\r\n            out.close();\r\n        }\r\n    } finally {\r\n        in.close();\r\n    }\r\n}\r\n```\r\n\r\n### try-with-resources\r\n앞서 설명한 문제들은 `try-with-resources`로 쉽게 해결이 가능하다.\r\n이 구조를 사용하기 위해서는 자원이 `AutoCloseable` 인터페이스를 구현하면 된다.\r\n\r\n```java\r\nstatic String firstLineOfFile(String path, String defaultVal) throws IOException {\r\n    // try-with-resouces 방식 사용\r\n    try (BufferedReader br = new BufferedReader(\r\n            new FileReader(path)\r\n    )) {\r\n        return br.readLine();\r\n    } catch (IOException e) {\r\n        return defaultVal;\r\n    }\r\n}\r\n```\r\n```java\r\nstatic void copy(String src, String dst) throws IOException {\r\n    \r\n    try (\r\n        InputStream in = new FileInputStream(src);\r\n        OutputStream out = new FileOutputStream(dst);\r\n    ) {\r\n        byte[] buf = new byte[BUFFER_SIZE];\r\n        int n;\r\n        while ((n = in.read(buf)) >= 0)\r\n            out.write(buf, 0, n);\r\n    }\r\n}\r\n```\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n"},{"excerpt":"객체를 생성했으면 나중에 사용이 끝났을 때는 없애기도 해야할 것이다. 자바는 두 가지 객체 소멸자를 제공하는데, 바로 와 이다. 그런데, 이 두 소멸자는 기본적으로 사용하지 말아야 한다. 그 이유는 크게 예측할 수 없고, 느리고, 위험하기 때문이다. 좀 더 자세하게 알아보자. 자바에서의 객체 회수 방법 C++에서는 자원을 회수하기 위해 destructor…","fields":{"slug":"/2022-05-27-effective-java-8/"},"frontmatter":{"date":"May 27, 2022","title":"[Effective Java] Item 8 - finalizer와 cleaner 사용을 피하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n객체를 생성했으면 나중에 사용이 끝났을 때는 없애기도 해야할 것이다. 자바는 두 가지 객체 소멸자를 제공하는데, 바로 `finalizer`와 `cleaner`이다.\r\n\r\n그런데, 이 두 소멸자는 기본적으로 사용하지 말아야 한다.\r\n\r\n그 이유는 크게 예측할 수 없고, 느리고, 위험하기 때문이다. 좀 더 자세하게 알아보자.\r\n\r\n### 자바에서의 객체 회수 방법\r\nC++에서는 자원을 회수하기 위해 destructor가 필요한데, Java에서는 가비지 컬렉터가 이 역할을 담당한다. 따라서 프로그래머는 객체를 회수하려는 작업을 하지 않아도 된다.\r\n또, 비메모리 자원을 회수할 때는 `try-with-resources`와 `try-finally`를 사용하기 때문에 객체 소멸자를 따로 사용할 이유는 더욱이 없는 것이다.\r\n\r\n### `finalizer`와 `cleaner`를 사용하지 말아야 하는 이유\r\n\r\n1. 즉시 수행된다는 보장이 없다.\r\n- 제때 실행되지 않고 가비지 컬렉터 알고리즘에 의해 실행되는 시간이 결정된다. \r\n- 실행되기까지 얼마나 걸릴지 알 수 없고 심지어는 실행되지 않을 수도 있다.그렇기 때문에, 중요한 일에 있어서는 큰 오류를 일으킬 수도 있다.\r\n\r\n2. 예외를 잡지 못한다.\r\n- `finalizer`는 예외 발생 시 스레드를 중단하여 종료시킨다. 경고조차 출력되지 않으므로 예측하기 어렵다.\r\n- `cleaner`는 스레드를 통제하기 때문에 이러한 문제를 발생시키진 않는다.\r\n\r\n3. 심각한 성능 문제를 동반한다.\r\n- `finalizer`가 가비지 컬렉터의 효율을 떨어뜨린다.\r\n- 안전망 방식을 사용하면 훨씬 빨라질 수 있지만, `try-with-resources`를 이용해 가비지 컬렉터가 객체를 수거하도록 하는 방식보다는 느리다.\r\n\r\n+) `finalizer` 안전망 방식\r\n\r\n4. `finalizer`는 심각한 보안 문제를 일으킬 수도 있다.\r\n- finalizer를 사용하다 예외가 발생하면 가비지 컬렉터가 수집하지 못하게 막는 공격이 발생할 수 있다. \r\n- 이 공격은 하위클래스의 finalizer가 실행되어 발생하기 때문에 하위 클래스를 생성할 수 없는 `final`로 선언하면 공격을 방지할 수 있다.\r\n\r\n### `AutoCloseable`을 사용하여 자원 회수하기\r\n\r\n`AutoCloseable`을 구현해 `close` 메서드를 호출시키면 finalizer와 cleaner를 대신할 수 있다.\r\n\r\n다만 구현할 때에 인스턴스가 닫혔는지를 추적하는 코드를 추가하면 좋다.\r\n\r\n### `cleaner`와 `finalizer`의 적절한 쓰임새\r\n1. 안전망 역할\r\n- 자원을 사용하는 클라이언트에서 close 메서드를 호출하지 않았을 때를 대비해 안전망 역할로 구현할 수 있다.\r\n- FileInputStream, FileOutputStream, ThreadPoolExecutor 등에서는 안전망 역할의 finalizer를 제공하기도 한다.\r\n\r\n2. 네이티브 피어(native peer)와 연결된 객체에서 사용\r\n- 네이티브 피어 : 일반 자바 객체가 기능을 위임한 네이티브 객체\r\n- 네이티브 피어는 자바 객체가 아니어서 가비지 컬렉터가 관여할 수 없다. 그러므로 cleaner나 finalizer로 직접 처리할 수 있다.\r\n- 다만, 성능 저하를 감당해야하고, 네이티브 피어가 사용하는 자원을 즉시 회수하지 않아도 되어야 한다. 이 경우가 아니라면 AutoCloseable의 close 메서드를 사용해야 한다.\r\n\r\n### `cleaner`를 안전망으로 활용하는 `AutoCloseable` 예시\r\n\r\n방(room) 자원을 회수하기 전에 반드시 청소(clean)해야 한다고 할 때, 자동 청소 안전망인 cleaner는 내부안에서 구현되기 때문에, 클래스의 public API에 나타나지 않는다.\r\n\r\n```java\r\npublic class Room implements AutoCloseable {\r\n    private static final Cleaner cleaner = Cleaner.create();\r\n\r\n    // 청소가 필요한 자원. 절대 Room을 참조해서는 안된다\r\n    private static class State implements Runnable {\r\n        int numJunkPiles; // 방(Room) 안의 쓰레기 수\r\n\r\n        State(int numJunkPiles) {\r\n            this.numJunkPiles = numJunkPiles;\r\n        }\r\n\r\n        // close 메서드나 cleaner가 호출된다.\r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"방 청소\");\r\n            numJunkPiles = 0;\r\n        }\r\n    }\r\n    // 방의 상태. cleanable과 공유한다.\r\n    // 방을 청소할 때 수거할 자원을 담고 있음\r\n    private final State state;\r\n\r\n    // cleanable 객체. 수거 대상이 되면 방을 청소한다.\r\n    private final Cleaner.Cleanable cleanable;\r\n\r\n    public Room(int numJunkPiles) {\r\n        state = new State(numJunkPiles);\r\n        cleanable = cleaner.register(this, state);\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        cleanable.clean();\r\n    }\r\n}\r\n```\r\n\r\n`Room`의 클라이언트 코드는 다음과 같다. `Adult` 클래스는 `try-with-resources`를 사용하여 잘 짜인 클라이언트이고, `Teenager` 클래스는 청소를 하지 않는 클라이언트이다. `Teenager`에서는 청소되지 않기 때문에 위에서 미리 만들어둔 안전망 `cleaner`로 청소가 될 것이다. 하지만, 진짜로 청소가 이뤄질지는 보장하지 않는다.(실행 여부 조차 모르기 때문이다.)\r\n\r\n```java\r\npublic class Adult {\r\n    public static void main(String[] args) {\r\n        try (Room myRoom = new Room(7)) {\r\n            System.out.println(\"안녕~\");\r\n        }\r\n    }\r\n}\r\n```\r\n```java\r\npublic class Teenager {\r\n    public static void main(String[] args) {\r\n        new Room(99);\r\n        System.out.println(\"아무렴\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [이펙티브 자바 완벽 공략 1부](https://www.inflearn.com/course/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-1/dashboard)\r\n"},{"excerpt":"Java의 경우, C, C++과는 달리 다 쓴 객체를 알아서 회수한다. 하지만 메모리 관리에 신경을 써야하는 몇 가지 경우가 있는데, 이러한 경우를 예시와 함께 알아보자.  1. 배열, 리스트 등으로 메모리를 관리하는 경우 책에 있는 예시인 스택 구현 코드를 보자.  메서드를 보면, 가 0일 때  객체를 생성만 하고, 빼지 않기 때문에  배열인 에 계속해…","fields":{"slug":"/2022-05-24-effective-java-7/"},"frontmatter":{"date":"May 24, 2022","title":"[Effective Java] Item 7 - 다 쓴 객체 참조를 해제하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\nJava의 경우, C, C++과는 달리 다 쓴 객체를 알아서 회수한다. 하지만 메모리 관리에 신경을 써야하는 몇 가지 경우가 있는데, 이러한 경우를 예시와 함께 알아보자. \r\n\r\n### 1. 배열, 리스트 등으로 메모리를 관리하는 경우\r\n\r\n책에 있는 예시인 스택 구현 코드를 보자.\r\n\r\n```java\r\npublic class Stack {\r\n    private Object[] elements;\r\n    private int size = 0;\r\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\r\n\r\n    public Stack() {\r\n        elements = new Object[DEFAULT_INITIAL_CAPACITY];\r\n    }\r\n\r\n    public void push(Object e) {\r\n        ensureCapacity();\r\n        elements[size++] = e;\r\n    }\r\n\r\n    public Object pop() {\r\n        if (size == 0) throw new EmptyStackException();\r\n        return elements[--size];\r\n    }\r\n\r\n    /*\r\n    * 원소를 위한 공간을 적어도 하나 이상 확보한다.\r\n    * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.\r\n    * */\r\n    private void ensureCapacity() {\r\n        if (elements.length == size)\r\n            elements = Arrays.copyOf(elements, 2 * size + 1);\r\n    }\r\n}\r\n```\r\n\r\n`pop()` 메서드를 보면, `size`가 0일 때 `EmptyStackException` 객체를 생성만 하고, 빼지 않기 때문에 `Object` 배열인 `elements`에 계속해서 쌓이게 될 것이다. \r\n그렇기 때문에 나중가서는 메모리 누수가 발생할 수 있다.\r\n\r\n이를 해결하기 위해서는, 다음과 같이 `pop()` 메서드를 구성하면 된다.\r\n\r\n```java\r\npublic Object pop() {\r\n    if (size == 0) throw new EmptyStackException();\r\n    Object result = elements[--size];\r\n    elements[size] = null;\r\n    return result;\r\n}\r\n```\r\n\r\n뺄 때 null을 이용해 객체 참조 해제를 같이 진행하면 메모리 누수를 막을 수 있게 되는 것이다.\r\n\r\n### 2. 캐시로 메모리를 관리하는 경우\r\n\r\n캐시에서의 메모리 누수를 살펴보기 위해, 책을 저장하는 캐시를 만들어보자.\r\n\r\n먼저, 캐시가 `Map` 형태를 가지므로, key와 value에 해당하는 객체를 생성하겠다.\r\n\r\n```java\r\nclass Key {\r\n    private Integer id;\r\n\r\n    public Key(Integer id) {\r\n        this.id = id;\r\n    }\r\n}\r\n```\r\n`Key` 객체는 간단히 `id` 인스턴스를 가지는 객체로 생성하였다. \r\n\r\n```java\r\nclass Book {\r\n    private String author;\r\n    private String category;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Book{\" +\r\n                \"author='\" + author + '\\'' +\r\n                \", category='\" + category + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n`Book` 객체는 책의 저자와 카테고리를 인스턴스로 하였다.\r\n\r\n캐시를 관리(setter, getter 등)할 수 있는 `CacheManager`는 다음과 같이 만들었다. 인스턴스는 `Map` 형태의 cache를 가지며, 앞서 만든 Key와 Book 객체를 가지고 값을 넣고 뺄 수 있는 메서드도 함께 생성하였다.\r\n\r\n```java\r\nclass CacheManager {\r\n\r\n    private Map<Key, Book> cache; // cache 인스턴스\r\n\r\n    public CacheManager() {\r\n        this.cache = new HashMap<>(); \r\n    }\r\n\r\n    public Book getBookById(Integer id) {\r\n        Key key = new Key(id);\r\n        if (cache.containsKey(key)) {\r\n            return cache.get(key);\r\n        } else {\r\n            Book book = new Book();\r\n            cache.put(key, book);\r\n            return book;\r\n        }\r\n    }\r\n\r\n    // cache 값을 가져오는 메서드. 예제에서는 캐시를 가져와 empty인지 확인하는 용도로 사용될 예정\r\n    public Map<Key, Book> getCache() {\r\n        return cache;\r\n    }\r\n}\r\n```\r\n\r\n이렇게 캐시 예제를 위해 다 만들었다면, 캐시 안에 값을 넣은 후 `System.gc()`를 이용해 캐시 안을 정리해보자.\r\n\r\n+) `System.gc()` : 가비지 컬렉터를 실행하여 메모리를 정리하는 메서드. 실행이 곧바로 된다는 보장은 없다.\r\n\r\n```java\r\npublic static void main(String[] args) throws InterruptedException {\r\n    CacheManager cacheManager = new CacheManager();\r\n    // cache에 id가 1에 해당하는 키를 가진 Book이 없으면 캐시에 새로 생성해 반환하고, 있으면 해당하는 값을 반환한다.\r\n    cacheManager.getBookById(1);\r\n    System.gc(); // 캐시 정리\r\n    Thread.sleep(3000);\r\n\r\n    System.out.println(\"isEmpty : \" + cacheManager.getCache().isEmpty());\r\n}\r\n```\r\n\r\n가비지 컬렉터를 실행하여 캐시를 정리한 후 캐시가 지워졌는지를 출력하면 다음과 같이 출력된다.\r\n\r\n> 출력 결과\r\n```\r\nisEmpty : false\r\n```\r\n\r\n캐시가 제대로 정리되지 않았다는 뜻이다. 이대로 캐시를 사용하면 메모리에 있는 내용은 사라지지 않고 계속 추가되어 결국 메모리 누수가 일어나게 될 것이다.\r\n\r\n이를 해결하는 방법은 캐시를 `HashMap`을 사용해서 만드는 것이 아니라 `WeakHashMap`으로 만들면 된다. `WeakHashMap`에 관한 자세한 설명은 [여기](링크)에서 확인할 수 있다.\r\n\r\n`WeakHashMap`으로 만든 뒤 코드를 다시 실행해보자.\r\n\r\n```java\r\nclass CacheManager {\r\n    ...\r\n\r\n    public CacheManager() {\r\n        this.cache = new WeakHashMap<>(); \r\n    }\r\n\r\n    ...\r\n}\r\n```\r\n```java\r\npublic static void main(String[] args) throws InterruptedException {\r\n    CacheManager cacheManager = new CacheManager();\r\n    // cache에 id가 1에 해당하는 키를 가진 Book이 없으면 캐시에 새로 생성해 반환하고, 있으면 해당하는 값을 반환한다.\r\n    cacheManager.getBookById(1);\r\n    System.gc(); // 캐시 정리\r\n    Thread.sleep(3000);\r\n\r\n    System.out.println(\"isEmpty : \" + cacheManager.getCache().isEmpty());\r\n}\r\n```\r\n\r\n> 출력 결과\r\n```\r\nisEmpty : true\r\n```\r\n\r\n이처럼 캐시를 사용할 경우에는, `WeakHashMap`을 이용하여 메모리 누수를 해결할 수 있다.\r\n\r\n#### 백그라운드 스레드(ScheduledThreadPoolExecutor)를 사용하여 캐시 청소하기\r\n\r\n`WeakHashMap`을 이용하는 방법 외에도 메모리 관리를 할 수 있다. 캐시 안의 가장 오래된 원소를 주기적으로 청소하는데, 이를 백그라운드 스레드를 이용하여 처리하는 방법이다.\r\n\r\n자세한 방법을 알아보기 전, 먼저 `ScheduledThreadPoolExecutor`에 대해 간단하게 알아보자.\r\n\r\n`ScheduledThreadPoolExecutor`는 어떤 작업을 일정 시간 지연 후에 수행하거나, 일정 시간 간격으로 주기적으로 실행해야 할 때 사용한다.\r\n\r\n`ScheduledThreadPoolExecutor`는 다음과 같은 메서드를 가지고 있다.\r\n- `schedule(Runnable command, long delay, TimeUnit unit)`\r\n    - 일정 시간 뒤에 작업 한 번 실행\r\n- `schedule(Callable command, long delay, TimeUnit unit)`\r\n    - 일정 시간 뒤에 작업 한 번 실행 후, 결과값 리턴\r\n- `scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`\r\n    - 일정 시간 간격으로 작업을 반복적으로 실행\r\n- `scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit)`\r\n    - 작업이 완료되면, 일정 시간 뒤에 다시 실행\r\n    - 작업 종료시점이 기준\r\n\r\n예제에서는 `scheduleAtFixedRate()`를 사용하여 반복적으로 오래된 원소를 청소할 것이다.\r\n\r\n사용하는 방법은 다음과 같다.\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\r\n    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); // 실행할 수 있는 객체 생성. 스레드 풀을 1로 설정하였다. \r\n\r\n    Runnable runnable = () -> System.out.println(\"Runnable task : \" + LocalDateTime.now()); // 스케줄에 따라 스레드에서 실행될 함수 설정\r\n    int delay = 3;\r\n\r\n    // 스케줄링\r\n    System.out.println(\"Scheduled task : \" + LocalDateTime.now() );\r\n    executor.schedule(runnable, delay, TimeUnit.SECONDS);\r\n}\r\n```\r\n\r\n> 출력 결과\r\n\r\n```\r\nScheduled task : 2022-05-25T21:44:05.329021900\r\nRunnable task : 2022-05-25T21:44:08.406786800\r\n```\r\n설정된 `delay` 시간 뒤에 실행되는 것을 볼 수 있다.\r\n\r\n`scheduleAtFixedRate()`를 사용한 예제도 살펴보자.\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); // 실행할 수 있는 객체 생성. 스레드 풀을 1로 설정하였다. \r\n\r\n    Runnable runnable = () -> System.out.println(\"Runnable task : \" + LocalDateTime.now()); // 스케줄에 따라 스레드에서 실행될 함수 설정\r\n    int initialDelay = 1; // 최초 실행될 때 발생되는 딜레이 설정\r\n    int period = 3; // 실행 간격 설정\r\n\r\n    // 스케줄링\r\n    System.out.println(\"Scheduled task : \" + LocalDateTime.now() );\r\n    executor.scheduleAtFixedRate(runnable, initialDelay, period, TimeUnit.SECONDS);\r\n\r\n    Thread.sleep(20000);\r\n    executor.shutdown();\r\n}\r\n```\r\n\r\n> 출력 결과\r\n```\r\nScheduled task : 2022-05-25T21:50:09.463414900\r\nRunnable task : 2022-05-25T21:50:10.525572900\r\nRunnable task : 2022-05-25T21:50:13.522554100\r\nRunnable task : 2022-05-25T21:50:16.514547\r\nRunnable task : 2022-05-25T21:50:19.526542300\r\nRunnable task : 2022-05-25T21:50:22.515494200\r\nRunnable task : 2022-05-25T21:50:25.523446900\r\nRunnable task : 2022-05-25T21:50:28.524457400\r\n```\r\n\r\n직접 실행해보면, 스레드가 shutdown되는 20초 동안 지정한 코드가 3초 간격으로 실행되는 것을 볼 수 있다.\r\n\r\n그럼 다시 본문으로 돌아와 `ScheduledThreadPoolExecutor`를 이용하여 메모리를 주기적으로 청소하는 예제를 살펴보자.\r\n\r\n오래된 원소를 파악하기 위해 `Key` 클래스에 `created` 인스턴스를 추가하였다. 이것으로 원소 생성 시간을 알 수 있다.\r\n\r\n```java\r\nclass Key {\r\n    private Integer id;\r\n    private LocalDateTime created;\r\n\r\n    public Key(Integer id) {\r\n        this.id = id;\r\n        this.created = LocalDateTime.now();\r\n    }\r\n\r\n    public LocalDateTime getCreated() {\r\n        return created;\r\n    }\r\n}\r\n```\r\n\r\n`Book`, `CacheManager` 클래스는 이전과 동일하다.\r\n\r\n```java\r\npublic static void main(String[] args) throws InterruptedException {\r\n    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\r\n    CacheManager cacheManager = new CacheManager();\r\n    cacheManager.getBookById(1); // cache에 Book 저장\r\n\r\n    Runnable runnable = () -> {\r\n            Map<Key, Book> cache = cacheManager.getCache();\r\n            Set<Key> keys = cache.keySet();\r\n            Optional<Key> key = keys.stream().min(Comparator.comparing(Key::getCreated)); // 오래된 key 찾기\r\n            key.ifPresent((k) -> { // 오래된 key에 해당하는 값을 cache에서 지우기\r\n                cache.remove(k);\r\n            });\r\n    };\r\n\r\n    executor.scheduleAtFixedRate(runnable, initialDelay, period, TimeUnit.SECONDS);\r\n\r\n    Thread.sleep(20000);\r\n    executor.shutdown();\r\n}\r\n```\r\n\r\n이렇게하면 지정된 스케줄에 따라 오래된 원소를 삭제하며 주기적으로 메모리를 관리할 수 있다.\r\n\r\n### 3. 리스너(listener, 또는 콜백(callback))를 사용하는 경우\r\n\r\n리스너를 사용하는 경우도 마찬가지로 어딘가에 리스너를 리스트(맵)에 담아둔 뒤, 이벤트 발생 시 리스너에 해당하는 메서드를 실행하게 된다.\r\n\r\n여기서도 리스너 리스트에 있는 원소를 제거하지 않으면 메모리 누수가 발생할 수 있는데, 앞서 설명한 캐시와 동일한 방법으로 메모리 관리를 할 수 있다.\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [이펙티브 자바 완벽 공략 1부](https://www.inflearn.com/course/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-1/dashboard)\r\n- [Java - ScheduledThreadPoolExecutor 사용 방법](https://codechacha.com/ko/java-scheduled-thread-pool-executor/)"},{"excerpt":"같은 기능의 객체를 불필요하게 만드는 것보다 재사용하는 것이 좋은데, 각각의 경우를 살펴보자. 불필요한 객체를 만드는 예 1 - 문자열 문자열에서 불필요한 객체를 만들게 되는 경우를 알아보자. 첫번째 코드는 String 객체를 계속해서 만드므로, 객체 생성이 불필요하게 될 수 있다.\n두번째 코드는 하나의 String 객체를 재사용한다.\n따라서 첫번째보다는…","fields":{"slug":"/2022-05-17-effective-java-6/"},"frontmatter":{"date":"May 17, 2022","title":"[Effective Java] Item 6 - 불필요한 객체 생성을 피하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n같은 기능의 객체를 불필요하게 만드는 것보다 재사용하는 것이 좋은데, 각각의 경우를 살펴보자.\r\n\r\n### 불필요한 객체를 만드는 예 1 - 문자열\r\n\r\n문자열에서 불필요한 객체를 만들게 되는 경우를 알아보자.\r\n\r\n```java\r\n// 1. String 인스턴스를 새로 생성\r\nString s1 = new String(\"apple\");\r\n\r\n// 2. 하나의 String 인스턴스를 계속해서 사용\r\nString s2 = \"apple\";\r\n```\r\n\r\n첫번째 코드는 String 객체를 계속해서 만드므로, 객체 생성이 불필요하게 될 수 있다.\r\n두번째 코드는 하나의 String 객체를 재사용한다.\r\n따라서 첫번째보다는 두번째 방법을 사용하는 것이 좋다.\r\n\r\n이와 같이 불변 클래스에서는 생성자 대신 [정적 팩터리 메서드](https://seonjuleee.github.io/2022-05-02-effective-java-1/)를 사용하면 불필요한 객체 생성을 피할 수 있다.\r\n\r\n또 다른 예제를 보자.\r\n\r\n정규표현식을 사용하여 복잡한 문자열의 유효성을 판단하는 메서드가 있다.\r\n```java\r\nstatic boolean isRomanNumeral(String s) {\r\n    return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\"\r\n            + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");\r\n}\r\n```\r\n여기서 `String.matches`을 사용하면 가장 쉽게 사용할 수 있는 방법이긴 하지만, 한 번 사용되고 버려지기 때문에 생성비용이 큰 정규표현식을 사용하기에는 성능이 좋지 않다.\r\n\r\n성능 개선을 위해 `Pattern` 인스턴스를 직접 생성해 캐싱해두고, 메서드 호출 시 이 인스턴스를 재사용하도록 하였다.\r\n\r\n```java\r\npublic class RomanNumerals {\r\n    private static final Pattern ROMAN = Pattern.compile(\r\n            \"^(?=.)M*(C[MD]|D?C{0,3})\"\r\n            + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");\r\n\r\n    static boolean isRomanNumeral(String s) {\r\n        return ROMAN.matcher(s).matches();\r\n    }\r\n}\r\n```\r\n\r\n### 불필요한 객체를 만드는 예 2 - 오토박싱\r\n먼저 오토박싱에 대해 알아보자.\r\n\r\n자바에는 기본(primitive)타입과 Wrapper 클래스가 있다.\r\n\r\n| 기본 타입 | Wrapper 클래스 |\r\n|-|-|\r\n|byte|Byte|\r\n|short|Short|\r\n|int|Integer|\r\n|long|Long|\r\n|float|Float|\r\n|double|Double|\r\n|char|Character|\r\n|boolean|Boolean|\r\n\r\n기본 타입의 데이터를 객체로 취급해야 하는 경우가 있는데 이때 Wrapper 클래스로 변환해 주면 된다. 이때 기본 타입을 Wrapper 클래스로 변환하는 과정을 **박싱(Boxing)**이라고 한다.\r\n반대로, Wrapper 클래스를 다시 기본 타입의 데이터로 꺼내 변환하는 과정을 **언박싱(UnBoxing)**이라고 한다.\r\n\r\n이처럼 기본 타입과 Wrapper 클래스를 자바 컴파일러가 자동으로 상호 변환해주는 기술을 **오토박싱/오토언박싱**이라고 한다.\r\n\r\n다시 돌아와서, 책에 있는 예시를 한 번 살펴보자.\r\n\r\n```java\r\nprivate static long sum() {\r\n    Long sum = 0L;\r\n    for (long i = 0; i <= Integer.MAX_VALUE; i++)\r\n        sum += i;\r\n\r\n    return sum;\r\n}\r\n```\r\n\r\n이 메서드는 `sum`을 Wrapper 클래스인 `Long`으로 선언하였는데, for문을 돌 때는 기본 타입의 `long` 타입인 `i`를 `sum`에 더해주고 있다. \r\n\r\n그렇게 되면 `sum`에 더해지기 위해 `long` 타입을 `Long` 타입으로 변환되는 오토박싱이 이루어지고, 이 과정이 `Integer.MAX_VALUE`인 2,147,483,647번 반복되고 있다.\r\n\r\n따라서 의도치 않은 오토박싱을 피하기 위해 `sum`을 Wrapper 클래스보단 기본 타입을 사용해야한다.\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [이펙티브 자바 완벽 공략 1부](https://www.inflearn.com/course/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-1/dashboard)\r\n- [Wrapper 클래스](http://www.tcpschool.com/java/java_api_wrapper)"},{"excerpt":"의존 관계 한 객체가 다른 객체를 생성하거나 메서드를 호출하면, 그 객체에 의존한다고 표현한다. 책에 예시로 나와있는  클래스는 스펠링이 맞는지 틀린지를 판단하는 클래스이기 때문에, 사전 클래스인 를 의존한다. 의존 관계를 정적 유틸리티 클래스와 싱글턴으로 구현 정적 유틸리티 클래스로 구현 싱글턴으로 구현 정적 유틸리티 클래스와 싱글턴으로 구현하게 되면,…","fields":{"slug":"/2022-05-16-effective-java-5/"},"frontmatter":{"date":"May 16, 2022","title":"[Effective Java] Item 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n### 의존 관계\r\n한 객체가 다른 객체를 생성하거나 메서드를 호출하면, 그 객체에 의존한다고 표현한다.\r\n\r\n책에 예시로 나와있는 `SpellChecker` 클래스는 스펠링이 맞는지 틀린지를 판단하는 클래스이기 때문에, 사전 클래스인 `Dictionary`를 의존한다.\r\n\r\n### 의존 관계를 정적 유틸리티 클래스와 싱글턴으로 구현\r\n\r\n- 정적 유틸리티 클래스로 구현\r\n```java\r\npublic class SpellChecker {\r\n    private static final Dictionary dictionary = new Dictionary();\r\n    \r\n    private SpellChecker() {} // 객체 생성 방지\r\n\r\n    public static boolean isValid(String word) {\r\n        ...\r\n    }\r\n\r\n    public static List<String> suggestions(String typo) {\r\n        ...\r\n    }\r\n}\r\n```\r\n- 싱글턴으로 구현\r\n```java\r\npublic class SpellChecker {\r\n    private final Dictionary dictionary = new Dictionary();\r\n    \r\n    private SpellChecker() {} \r\n    public static SpellChecker INSTANCE = new SpellChecker();\r\n\r\n    public static boolean isValid(String word) {\r\n        ...\r\n    }\r\n\r\n    public static List<String> suggestions(String typo) {\r\n        ...\r\n    }\r\n}\r\n```\r\n정적 유틸리티 클래스와 싱글턴으로 구현하게 되면, 유연하지 않고 테스트하기 어렵다는 단점이 있다.\r\n\r\n사전은 일반 사전만 있는 것이 아닌 영어 사전, 국어 사전, 불어 사전 등 언어별로 따로 있을 수 있고, 고대 영어 사전과 같이 특수 어휘용 사전을 따로 둘 수도 있다. \r\n\r\n그런데 방금 구현한 방법으로는 여러 가지 사전을 사용하도록 할 수 없다. 사용할 수 있도록 만드려면, `EngSpellChecker`, `KorSpellChecker` 클래스를 만들고 그 안에 각각 해당하는 `EngDictionary`, `KorDictionary` 클래스를 선언하는 복잡한 방식을 거쳐야 할 것 이다.\r\n\r\n따라서 사용하는 자원에 따라 동작이 달라지는 클래스의 경우에는, \r\n```java\r\n    private final Dictionary dictionary = new Dictionary();\r\n```\r\n정적 유틸리티 클래스와 싱글턴처럼 자원을 직접 명시하는 것이 아니라 의존 객체 주입을 사용하면 된다.\r\n\r\n### 의존 객체 주입\r\n의존 객체 주입 방법은 인스턴스를 생성할 때 필요한 자원을 넘겨주면 된다.\r\n대신 의존 객체인 이 `Dictionary`는 `interface`여야 한다.\r\n\r\n```java\r\npublic class SpellChecker {\r\n    private final Dictionary dictionary;\r\n\r\n    public SpellChecker(Dictionary dictionary) {\r\n        this.dictionary = dictionary;\r\n    }\r\n\r\n    public boolean isValid(String word) {\r\n        ...\r\n    }\r\n\r\n    public List<String> suggestions(String typo) {\r\n        ...\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [이펙티브 자바 완벽 공략 1부](https://www.inflearn.com/course/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-1/dashboard)"},{"excerpt":"정적 멤버만 담은 유틸리티 클래스 정적 메서드와 정적 필드만을 담은 단순한 클래스는 다음과 같이 사용된다. 기본 타입 값이나 배열 관련 메서드 모으기 ex. ,  인터페이스를 구현하는 객체를 생성해주는 정적 메서드(또는 팩터리)를 모으기 ex.  final 클래스와 관련한 메서드 모으기 final 클래스를 상속받아 메서드에 넣을 수 없기 때문이다. 이런 …","fields":{"slug":"/2022-05-10-effective-java-4/"},"frontmatter":{"date":"May 10, 2022","title":"[Effective Java] Item 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n### 정적 멤버만 담은 유틸리티 클래스\r\n정적 메서드와 정적 필드만을 담은 단순한 클래스는 다음과 같이 사용된다.\r\n\r\n- 기본 타입 값이나 배열 관련 메서드 모으기\r\n    - ex. `java.lang.Math`, `java.util.Arrays`\r\n- 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(또는 팩터리)를 모으기\r\n    - ex. `java.util.Collections`\r\n- final 클래스와 관련한 메서드 모으기\r\n    - final 클래스를 상속받아 메서드에 넣을 수 없기 때문이다.\r\n\r\n이런 클래스는 인스턴스로 만들어 쓰려고 만들어진 것이 아니다.\r\n그러나, 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다.\r\n따라서 인스턴스화를 막아야한다.\r\n\r\n인스턴스화를 막는 방법은 아주 간단하다. \r\nprivate 생성자를 추가하면 된다.\r\n\r\n```java\r\npublic class UtilityClass {\r\n    // 기본 생성자가 만들어지는 것을 막는다(인스턴스 방지용).\r\n    private UtilityClass() {\r\n        throw new AssertionError();\r\n    }\r\n}\r\n```\r\n\r\n꼭 `AssertionError`를 던질 필요는 없지만 실수로라도 생성자를 호출하지 않도록 해준다.\r\n다만 생성자가 존재하는데 호출할 수 없으므로, 예시처럼 적절한 주석을 달아주면 좋다.\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n"},{"excerpt":"싱글턴(singleton) 객체의 인스턴스를 오직 1개만 생성할 수 있는 클래스. 생성자의 호출이 반복적으로 이뤄져도 객체는 최초 생성된 객체를 반환해준다. 클래스를 싱글턴으로 만드는 이유? 메모리 낭비를 방지할 수 있다 최초 한 번 생성하면 이후에도 고정된 메모리 영역을 사용하기 때문에 객체에 접근할 때 메모리 낭비를 방지할 수 있다. 다른 클래스 간에…","fields":{"slug":"/2022-05-09-effective-java-3/"},"frontmatter":{"date":"May 09, 2022","title":"[Effective Java] Item 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n### 싱글턴(singleton)\r\n객체의 인스턴스를 오직 1개만 생성할 수 있는 클래스. 생성자의 호출이 반복적으로 이뤄져도 객체는 최초 생성된 객체를 반환해준다.\r\n\r\n### 클래스를 싱글턴으로 만드는 이유?\r\n- 메모리 낭비를 방지할 수 있다\r\n    - 최초 한 번 생성하면 이후에도 고정된 메모리 영역을 사용하기 때문에 객체에 접근할 때 메모리 낭비를 방지할 수 있다.\r\n- 다른 클래스 간에 데이터 공유가 쉽다\r\n    - 싱글턴 인스턴스가 전역으로 사용되기 때문에 다른 클래스의 인스턴스들이 접근하여 사용 가능하다.\r\n\r\n### 싱글턴의 단점\r\n- 싱글톤을 구현하는 코드 자체가 많이 필요하다\r\n- 테스트하기 어렵다\r\n    - 테스트를 할 때 마다 매번 인스턴스의 상태를 초기화시켜주어야 한다.\r\n- 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 해결해야 한다\r\n- 해당 싱글턴 객체를 사용하는 다른 객체 간의 결함도가 높아져 객체 지향 설계 원칙에 어긋나게 된다\r\n- 자식클래스를 만들 수 없다\r\n\r\n### 싱글턴을 만드는 방식 1 - public static final 필드 방식\r\n생성자는 `private`로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 `public static` 멤버를 `final`으로 하나 마련한다.\r\n\r\n```java\r\npublic class Elvis {\r\n    public static final Elvis INSTANCE = new Elvis();\r\n    private Elvis() {} // 생성자\r\n\r\n    public void leaveTheBuilding() {}\r\n}\r\n```\r\n생성자는 `Elvis.INSTANCE`를 초기화할 때 딱 한 번 호출된다. 생성자가 `private`이므로, `publi`c이나 `protected` 생성자가 없기 때문에 `Elvis` 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 클래스가 하나인 것으로 보증된다.\r\n\r\n이렇게 만들면 간결하면서도 해당 클래스가 싱글턴임을 API에 명백하게 드러낼 수 있다.\r\n\r\n### 싱글턴을 만드는 방식 2 - 정적 팩터리 방식의 싱글턴\r\n\r\n정적 팩터리 메서드를 `public static`으로 만드는 방식이다.\r\n\r\n```java\r\npublic class Elvis {\r\n    public static final Elvis INSTANCE = new Elvis();\r\n    private Elvis() {} // 생성자\r\n    public static Elvis getInstance() {\r\n        return INSTANCE;\r\n    }\r\n\r\n    public void leaveTheBuilding() {}\r\n}\r\n```\r\n\r\n정적 팩터리 메서드인 `Elvis.getInstance`는 항상 같은 객체의 참조를 반환하도록 되어있다. \r\n\r\n이 방식의 장점\r\n- API를 바꾸지 않고도 싱글턴이 아닌 다른 것으로 변경할 수 있다\r\n- 정적팩터리를 제네릭 싱글턴 팩터리로도 만들 수 있다\r\n- 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다\r\n\r\n### 싱글턴을 만드는 방식 3 - 원소가 하나인 열거 타입 선언\r\npublic 필드 방식과 비슷하지만, 클래스를 열거 타입으로 만드는 방법이다. 싱글턴 생성 방법 중 가장 바람직한 방법이다.\r\n\r\n```java\r\npublic enum Elvis {\r\n    INSTANCE;\r\n\r\n    public void leaveTheBuilding() {}\r\n}\r\n```\r\n\r\n이 방식의 장점\r\n- 더 간결하다\r\n- 직렬화를 간단하게 할 수 있다\r\n\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [싱글톤(Singleton) 패턴이란?](https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/)\r\n"},{"excerpt":"선택적 매개변수가 많을 때는 정적 팩터리 메서드와 생성자 모두 적절하게 대응하기가 힘든데, 빌더 패턴을 사용하면 해결 가능하다. 점층적 생성자 패턴(Telescoping constructor pattern) 빌더 패턴을 설명하기 전, 비교를 위해 다른 패턴들을 살펴보자. 빌더 패턴 전에는 점층적 생성자 패턴을 사용하여 이 문제를 해결했다고 한다.  클래스…","fields":{"slug":"/2022-05-03-effective-java-2/"},"frontmatter":{"date":"May 03, 2022","title":"[Effective Java] Item 2 - 생성자에 매개변수가 많다면 빌더를 고려하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n선택적 매개변수가 많을 때는 정적 팩터리 메서드와 생성자 모두 적절하게 대응하기가 힘든데, **빌더 패턴**을 사용하면 해결 가능하다.\r\n\r\n### 점층적 생성자 패턴(Telescoping constructor pattern)\r\n\r\n빌더 패턴을 설명하기 전, 비교를 위해 다른 패턴들을 살펴보자. 빌더 패턴 전에는 점층적 생성자 패턴을 사용하여 이 문제를 해결했다고 한다.\r\n\r\n`Student` 클래스로 예를 들어 보자.\r\n```java\r\npublic class Member {\r\n    private final String name; // 필수\r\n    private final String address; \r\n    private final String number;\r\n}\r\n```\r\n여기서 매개변수를 선택하여 생성할 수 있도록 만들어보면, 점층적 생성자 패턴의 경우는 다음과 같이 만들어진다.\r\n\r\n```java\r\npublic class Member {\r\n    private final String name; // 필수\r\n    private final String address; \r\n    private final String number;\r\n\r\n    public Member(String name) {\r\n        this(name, null);\r\n    }\r\n\r\n    public Member(String name, String address) {\r\n        this(name, address, null);\r\n    }\r\n\r\n    public Member(String name, String address, String number) {\r\n        this.name = name;\r\n        this.address = address;\r\n        this.number = number;\r\n    }\r\n}\r\n\r\n```\r\n\r\n이 클래스를 생성하려면 원하는 매개변수를 모두 포함한 생성자 중, 가장 짧은 것을 골라 호출하면 된다.\r\n\r\n```java\r\nMember member = new Member(\"홍길동\", \"서울시\", \"010-1234-5678\");\r\n```\r\n\r\n여기서 만약에 `address`를 뺀 `name`, `number` 변수만 가지고 객체를 생성하려면 다음 나타낸 것처럼 `address` 값을 `null`로 주어야 한다.\r\n\r\n```java\r\nMember member = new Member(\"홍길동\", null, \"010-1234-5678\");\r\n```\r\n\r\n점층적 생성자 패턴은 \r\n- 사용자가 설정하기를 원치 않는 매개변수도 값을 지정해야함\r\n- 매개변수 개수가 많아지면 클라이언트 코드가 복잡해짐\r\n\r\n이런 단점을 가지고 있다.\r\n\r\n### 자바빈즈 패턴(JavaBeans pattern)\r\n자바빈즈 패턴은 매개변수가 없는 생성자로 객체를 만든 후, setter 메서드로 매개변수의 값을 설정하는 방식의 패턴이다.\r\n\r\n자바빈즈 패턴으로 `Member` 클래스를 나타내보자.\r\n\r\n```java\r\npublic class Member {\r\n    private String name = null; // 필수\r\n    private String address = null;\r\n    private String number = null;\r\n\r\n    public Member() {}\r\n\r\n    // setter 메서드\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n    public void setNumber(String number) {\r\n        this.number = number;\r\n    }\r\n}\r\n```\r\n\r\n자바빈즈 패턴은 점층적 생성자 패턴과는 달리 복잡하지 않지만,\r\n- 객체 하나를 생성하기 위해 메서드를 여러 개 호출해야 함\r\n- 객체 생성 전까지 일관성(consistency)이 무너짐\r\n- 일관성이 무너지기 때문에 불변으로 생성 불가\r\n\r\n하다는 단점을 가지고 있다.\r\n\r\n### 빌더 패턴(Builder pattern)\r\n\r\n빌더 패턴은 빌더 객체를 이용하여 선택 매개변수를 설정할 수 있다.\r\n\r\n빌더 패턴으로 만든 `Member` 클래스를 보자.\r\n\r\n```java\r\npublic class Member {\r\n    private final String name; // 필수\r\n    private final String address;\r\n    private final String number;\r\n\r\n    public static class Builder {\r\n        // 필수 매개변수\r\n        private final String name;\r\n\r\n        // 선택 매개변수 - 기본값으로 초기화\r\n        private String address = null;\r\n        private String number = null;\r\n\r\n        public Builder(String name) {\r\n            this.name = name;\r\n        }\r\n\r\n        public Builder address(String val) {\r\n            address = val;\r\n            return this;\r\n        }\r\n\r\n        public Builder number(String val) {\r\n            number = val;\r\n            return this;\r\n        }\r\n\r\n        public Member build() {\r\n            return new Member(this);\r\n        }\r\n    }\r\n\r\n    private Member(Builder builder) {\r\n        name = builder.name;\r\n        address = builder.address;\r\n        number = builder.number;\r\n    }\r\n}\r\n```\r\n\r\n`Member` 클래스를 생성하려면 다음처럼 연쇄적으로 메서드를 호출시키면 된다.\r\n\r\n```java\r\nMember member = new Member.Builder(\"홍길동\")\r\n                .address(\"서울시\")\r\n                .number(\"010-1234-5678\")\r\n                .build();\r\n```\r\n\r\n### 계층적인 클래스에서의 빌더 패턴\r\n빌더 패턴은 계층구조를 가진 클래스에서 사용하기 좋다. 추상 클래스는 추상 빌더를, 구체 클래스(concrete class)는 구체 빌더를 가지게 한다.\r\n\r\n책의 예시에 있는 `Pizza` 추상 클래스를 자세하게 보자.\r\n\r\n먼저 `Pizza` 클래스는 토핑과 토핑을 `Set`으로 엮은 toppings를 인스턴스로 가진다. \r\n\r\n```java\r\npublic enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE;}\r\nfinal Set<Topping> toppings;\r\n```\r\n추상 클래스이므로 클래스를 생성하는 추상 빌더를 이렇게 나타낼 수 있다.\r\n\r\n```java\r\n// Pizza.Builder 클래스는 제네릭 타입으로, Builder 타입만 사용되도록 제한되었다고 생각하면 좋다.\r\nabstract static class Builder<T extends Builder<T>> {\r\n\r\n    // toppings는 선택 매개변수로 EnumSet.noneOf를 통해 초기화 됨\r\n    EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);\r\n    // topping을 더해 자기 자신을 반환\r\n    // Member 예제의 address와 같은 역할\r\n    public T addTopping(Topping topping) {\r\n        toppings.add(Objects.requireNonNull(topping));\r\n        return self();\r\n    }\r\n\r\n    abstract Pizza build();\r\n\r\n    // 하위 클래스는 이 메서드를 overring하여 \"this\"를 반환하도록 해야한다.\r\n    // self를 더해 하위클래스에서는 형변환 하지 않고도 메서드 연쇄를 지원할 수 있다.\r\n    protected abstract T self();\r\n    }\r\n}\r\n\r\n```\r\n\r\n빌더를 통해 `Pizza`를 생성하는 코드는 `Builder`에서 `addTopping`을 통해 추가된 `toppings`를 `Pizza`의 `toppings`에 `clone`하도록 했다.\r\n```java\r\nPizza(Builder<?> builder) {\r\n    toppings = builder.toppings.clone();\r\n}\r\n```\r\n\r\n합치면 `Pizza` 추상 클래스는 이렇게 구성된다.\r\n\r\n```java\r\npublic abstract class Pizza {\r\n\r\n    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE;}\r\n    final Set<Topping> toppings;\r\n\r\n    abstract static class Builder<T extends Builder<T>> {\r\n        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);\r\n        public T addTopping(Topping topping) {\r\n            toppings.add(Objects.requireNonNull(topping));\r\n            return self();\r\n        }\r\n\r\n        abstract Pizza build();\r\n\r\n        protected abstract T self();\r\n    }\r\n\r\n    Pizza(Builder<?> builder) {\r\n        toppings = builder.toppings.clone();\r\n    }\r\n}\r\n```\r\n\r\n추상 클래스로 정의한 `Pizza`에 뉴욕 피자인 `NyPizza`, 칼조네 피자인 `Calzone` 두 하위 클래스가 있다고 하자. 그러면 빌더 패턴으로 나타낸 클래스는 다음처럼 표현된다.\r\n\r\n- `NyPizza`\r\n```java\r\npublic class NyPizza extends Pizza{\r\n    public enum Size { SMALL, MEDIUM, LARGE }\r\n    private final Size size; // NyPizza에는 size가 필수 매개변수\r\n\r\n    public static class Builder extends Pizza.Builder<Builder> {\r\n        private final Size size;\r\n\r\n        public Builder(Size size) {\r\n            this.size = Objects.requireNonNull(size);\r\n        }\r\n\r\n        // Pizza 클래스에 있는 build 추상 메서드에 NyPizza를 반환하도록 구현\r\n        @Override public NyPizza build() {\r\n            return new NyPizza(this);\r\n        }\r\n\r\n        // self도 this를 반환하도록 구현\r\n        @Override\r\n        protected Builder self() {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    NyPizza(Builder builder) {\r\n        super(builder);\r\n        size = builder.size;\r\n    }\r\n}\r\n```\r\n\r\n- `Calzone`\r\n```java\r\npublic class Calzone extends Pizza {\r\n    private final boolean sauceInside; // Calzone에는 sauceInside가 필수 매개변수\r\n\r\n    public static class Builder extends Pizza.Builder<Builder> {\r\n        private boolean sauceInside = false; // 기본값\r\n\r\n        public Builder sauceInside() {\r\n            sauceInside = true;\r\n            return this;\r\n        }\r\n\r\n        // Pizza 클래스에 있는 build 추상 메서드에 Calzone를 반환하도록 구현\r\n        @Override public Calzone build() {\r\n            return new Calzone(this);\r\n        }\r\n\r\n        // self도 this를 반환하도록 구현\r\n        @Override protected Builder self() {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    private Calzone(Builder builder) {\r\n        super(builder);\r\n        sauceInside = builder.sauceInside;\r\n    }\r\n}\r\n```\r\n\r\n이렇게 빌더 패턴을 계층적으로 설계하면 `NyPizza`와 `Calzone`를 구현하는 클라이언트 코드는 간단하게 나타낼 수 있다.\r\n\r\n```java\r\nNyPizza pizza = new NyPizza.Builder(NyPizza.Size.SMALL)\r\n        .addTopping(Pizza.Topping.SAUSAGE)\r\n        .addTopping(Pizza.Topping.ONION).build();\r\nCalzone calzone = new Calzone.Builder()\r\n        .addTopping(Pizza.Topping.HAM)\r\n        .sauceInside().build();\r\n```\r\n\r\n\r\n빌더 패턴은 매우 유연하게 사용할 수 있다는 장점이 크다. Lombok 라이브러리를 사용하면 `@Builder` 어노테이션 하나로 빌더 패턴을 더 쉽게 구현할 수 있다. \r\n\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n"},{"excerpt":"정적 팩터리 메서드 정적 팩터리 메서드(static factory method)는 클래스의 인스턴스를 반환하는 정적 메서드이다.  예를 몇 가지 들어보자.  클래스의  메서드  클래스의  메서드 두 메서드 다 반환 값이 클래스인 정적 메서드이기 때문에, 객체 생성의 역할을 할 수 있다. 그렇다면 왜 생성자 대신 정적 팩터리 메서드를 고려해야할까? 정적 팩…","fields":{"slug":"/2022-05-02-effective-java-1/"},"frontmatter":{"date":"May 02, 2022","title":"[Effective Java] Item 1 - 생성자 대신 정적 팩터리 메서드를 고려하라","tags":["Java","Effective Java"]},"rawMarkdownBody":"\r\n### 정적 팩터리 메서드\r\n정적 팩터리 메서드(static factory method)는 **클래스의 인스턴스를 반환하는 정적 메서드**이다. \r\n\r\n예를 몇 가지 들어보자.\r\n\r\n- `Boolean` 클래스의 `valueOf` 메서드\r\n\r\n```java\r\npublic static Boolean valueOf(boolean b) {\r\n    return (b ? TRUE : FALSE);\r\n}\r\n```\r\n\r\n- `LocalTime` 클래스의 `now` 메서드\r\n\r\n```java\r\npublic static LocalTime now() {\r\n    return now(Clock.systemDefaultZone());\r\n}\r\n```\r\n\r\n두 메서드 다 반환 값이 클래스인 정적 메서드이기 때문에, 객체 생성의 역할을 할 수 있다.\r\n\r\n그렇다면 왜 생성자 대신 정적 팩터리 메서드를 고려해야할까?\r\n\r\n### 정적 팩터리 메서드가 생성자보다 좋은 이유\r\n\r\n#### 1. 이름을 가질 수 있다\r\n생성자의 경우, 매개변수와 생성자 자체만으로는 반환되는 객체의 특성을 제대로 설명하지 못한다.\r\n\r\n좀 더 자세히 알아보기 위해 **값이 소수인 `BigInteger`를 반환**하는 예제를 각각 들어보자.\r\n\r\n- 생성자의 경우\r\n```java\r\npublic BigInteger(int bitLength, Random rnd) {\r\n    ...\r\n}\r\n```\r\n\r\n- 정적 팩터리 메서드의 경우\r\n```java\r\npublic static BigInteger probablePrime(int bitLength, Random rnd) {\r\n    ...\r\n}\r\n```\r\n\r\n정적 팩터리 메서드는 `probablePrime`이라는 메서드 이름을 통해 반환되는 객체의 의미를 좀 더 명확하게 표현할 수 있다.\r\n\r\n#### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다\r\n\r\n정적 팩터리 메서드를 사용하면, \r\n- 인스턴스를 미리 만들어 놓거나 \r\n- 새로 생성한 인스턴스를 캐싱하여 재활용하는\r\n방식으로 불필요하게 객체를 생성하는 것을 방지할 수 있다.\r\n\r\n대표적인 예로, `Boolean.valueOf(boolean)` 메서드는 객체를 아예 생성하지 않는다.\r\n\r\n```java\r\npublic static Boolean valueOf(boolean b) {\r\n    return (b ? TRUE : FALSE);\r\n}\r\n```\r\n\r\n또 다른 예로 로또 번호를 생성하는 메서드를 보자.\r\n\r\n```java\r\npublic class LottoNumber {\r\n    private static final int MIN_LOTTO_NUMBER = 1;\r\n    private static final int MAX_LOTTO_NUMBER = 45;\r\n    \r\n    private static Map<Integer, LottoNumber> lottoNumberCache = new HashMap<>();\r\n    \r\n    static {\r\n      IntStream.range(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER)\r\n                  .forEach(i -> lottoNumberCache.put(i, new LottoNumber(i)));\r\n    }\r\n    \r\n    private int number;\r\n    \r\n    private LottoNumber(int number) {  \r\n      this.number = number;\r\n    }\r\n    \r\n    public LottoNumber of(int number) {  // LottoNumber를 반환하는 정적 팩토리 메서드\r\n      return lottoNumberCache.get(number);\r\n    }\r\n    \r\n    ...\r\n}\r\n```\r\n| 출처 https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\r\n\r\n정적 팩터리 메서드를 통해 로또 번호 객체를 새로 생성하는 것이 아니라 캐싱을 통해서 불필요한 객체 생성을 막을 수 있다. \r\n\r\n또, 생성자의 접근 제한자를 `private`로 설정하여 객체 생성을 정적 팩터리 메서드로만 가능하게 제한할 수 있다.\r\n\r\n#### 3. 반환 타입의 하위 타입 객체를 반환할 수 있다\r\n\r\n`Coffee`를 상속받는 하위 클래스 `Americano`, `Latte`, `Espresso`가 있다고 하자.\r\n\r\n```java\r\npublic class Coffee {\r\n    ...\r\n    public static Coffee of(String ingredient) {\r\n        if (ingredient.equals(\"water\")) {\r\n            return new Americano();\r\n        } else if (ingredient.equals(\"milk\")) {\r\n            return new Latte();\r\n        } else () {\r\n            return new Espresso();\r\n        }\r\n    }\r\n    ...\r\n}\r\n```\r\n정적 팩터리 메서드인 `of`에서는 재료에 따라 원하는 하위 클래스를 반환시킬 수 있다.\r\n\r\n이처럼 반환할 객체의 클래스를 자유롭게 선택할 수 있기 때문에, 굉장히 유연하게 만들 수 있다는 장점이 있다.\r\n\r\n#### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다\r\n\r\n`EnumSet` 클래스에서는, public 생성자 없이 정적 팩터리만 제공하는데, 원소의 수에 따라 두 가지 하위 클래스(`RegularEnumSet`, `JumboEnumSet`) 중 하나의 인스턴스를 반환한다.\r\n\r\n`EnumSet`의 `noneOf` 메서드를 보자. 제네릭 때문에 복잡해 보이지만 밑에 if 문만 보면 된다.\r\n```java\r\npublic static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {\r\n    Enum<?>[] universe = getUniverse(elementType);\r\n    if (universe == null)\r\n        throw new ClassCastException(elementType + \" not an enum\");\r\n\r\n    if (universe.length <= 64)\r\n        return new RegularEnumSet<>(elementType, universe);\r\n    else\r\n        return new JumboEnumSet<>(elementType, universe);\r\n}\r\n\r\n```\r\n\r\n`noneOf` 메서드는 EnumSet을 반환하는 정적 팩터리 메서드인데, 입력 매개변수인 `elementType`에 의해 결정된 `universe`의 길이가 65를 기점으로 작으면 `RegularEnumSet`을 반환하고, 크면 `JumboEnumSet`를 반환한다.\r\n\r\n이처럼 정적 팩터리 메서드를 사용하면 입력 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다.\r\n\r\n#### 5. 작성 시점에 반환할 객체의 클래스가 존재하지 않아도 된다\r\n\r\n### 정적 팩터리 메서드의 단점\r\n\r\n#### 1. 상속 시 정적 팩터리 메서드만 제공하면 하위클래스를 생성할 수 없다\r\n상속을 하게 되면 public이나 protected 생성자가 필요하기 때문이다.\r\n그러나, 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들기 위해서는 이 제약을 지켜야하기 때문에 장점이 될 수 있다.\r\n\r\n#### 2. 프로그래머가 찾기 힘들다\r\nAPI 설명이 명확하게 드러나지 않기 때문에 사용자가 사용하는 방식을 알아내야 한다.\r\n\r\n### 정적 팩터리 메서드에서 흔하게 사용하는 네이밍 방식\r\n- `from` : 매개변수를 하나 받아서 해당 타입의 객체 생성\r\n- `of` : 여러 매개변수를 받아 적합한 타입의 객체 생성\r\n- `valueOf` : `from`과 `of`의 더 자세한 버전\r\n- `instance | getInstance` : 매개변수로 명시한 인스턴스를 반환. 그러나 같은 인스턴스라는 보장 X\r\n- `create | newInstance` : `instance`, `getInstance`와 같지만, 매번 새로운 인스턴스를 생성해 반환\r\n- `getType | newType` : `getInstance`, `newInstance`와 같으나, 다른 클래스에 팩터리 메서드를 정의할 때 사용\r\n- `type` : `getType`과 `newType`의 간결한 버전\r\n\r\n### 참고\r\n- [이펙티브 자바](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171196410)\r\n- [정적 팩토리 메서드는 왜 사용할까?](https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C)\r\n\r\n\r\n"},{"excerpt":"이번 주 계획 이행 실전 JPA 강의, Spring Data JPA 강의 듣고 프로젝트 구성 ⭕ 토이프로젝트 로그인 화면 구현 ❌  토이프로젝트 필요한 API 정리 ⭕ '부의 추월차선' 책 끝내기 ❌ 블로그 글 짧게 2번 포스팅하기 ❌ 해낸 일 운동을 주 3회 했다 책 '이펙티브 자바'의 내용을 정리해서 블로그에 올리기로 했다 현재 이펙티브 자바 책을 읽…","fields":{"slug":"/2022-05-01-weekly-report/"},"frontmatter":{"date":"May 01, 2022","title":"4월 다섯째주 주간 회고","tags":["회고"]},"rawMarkdownBody":"\r\n### 이번 주 계획 이행\r\n- 실전 JPA 강의, Spring Data JPA 강의 듣고 프로젝트 구성 ⭕\r\n- 토이프로젝트 로그인 화면 구현 ❌ \r\n- 토이프로젝트 필요한 API 정리 ⭕\r\n- '부의 추월차선' 책 끝내기 ❌\r\n- 블로그 글 짧게 2번 포스팅하기 ❌\r\n\r\n### 해낸 일\r\n- 운동을 주 3회 했다\r\n\r\n- 책 '이펙티브 자바'의 내용을 정리해서 블로그에 올리기로 했다\r\n  - 현재 이펙티브 자바 책을 읽고 잘 모르는 부분에 대해 질문하고 공유하는 스터디를 하고 있는데, 중반 정도 진행되다 보니 배우는 아이템의 수가 많아져 개념을 정리하는 과정이 필요하다고 느꼈다. 그래서 내가 블로그에 정리하는 것을 제안했다. 지금까지 하는 일에서 추가로 일주일 동안 아이템 2개씩 각자의 블로그에 정리해보기로 했다.\r\n\r\n- ['지속가능한 SW 개발을 위한 코드리뷰' 세미나](https://www.youtube.com/watch?v=ssDMIcPBqUE)를 들었다\r\n  - 지금껏 코드리뷰를 계속 하지 못했어서 코드리뷰를 잘 하기 위해서는 어떤 방식이 필요한지 궁금해서 듣게 되었다. 세미나에서는 크게 코드리뷰를 해야하는 이유, 효율적인 코드리뷰를 하는 방법으로 나누어 진행되었다. 세미나를 들으면서 코드리뷰의 필요성을 느낄 수 있었고, 원활한 코드리뷰를 위해서 리뷰받는 사람과 리뷰하는 사람 모두 어떻게 해야지에 대해서도 알 수 있었다. 간략하게 얘기하자면 코드리뷰를 받는 사람은 리뷰를 하는 사람이 코드를 좀 더 빠르게 이해할 수 있도록 노력을 기울여야하고, 코드리뷰를 하는 사람은 리뷰를 받는 사람을 존중하고 기다리지 않도록 받는 즉시 할 수 있도록 해야한다는 것이었다.  \r\n  현재 회사에서는 코드리뷰를 하지 않고 있어서 경험할 수 있는 상황이 적었는데, 코드리뷰를 혼자서 해볼 수도 있음을 알게 되어 현재 하고 있는 프로젝트에도 진행해보고 싶다는 생각을 했다. 또 코드리뷰를 중점적으로한 간단한 팀프로젝트를 해보면서 코드리뷰를 익혀봐야겠다.\r\n  \r\n### 부족했던 점\r\n- 계획했던 일을 많이 하지 못했다\r\n  - 갑자기 금요일부터 의욕을 조금 잃어서 계획했던 많은 일들을 하지 못했다. 한정된 시간에 비해 계획한 일들이 좀 버거운가 싶어서 다음 주에는 목표를 덜 잡고 좋아하는 일의 비중을 높여볼 것이다.\r\n\r\n### 회사 업무\r\n- Couchbase를 적용했다\r\n  - 로그를 저장하는 기능을 추가해야해서 NoSQL인 Couchbase를 적용하기로 했다. 설정하고 Spring Boot 프로젝트와 연동하는 방법을 배웠다.\r\n\r\n### 다음주 계획\r\n- 실전 JPA 강의, Spring Data JPA 강의 수강\r\n- 토이프로젝트 로그인 화면 구현\r\n- '부의 추월차선' 책 끝내기\r\n- 이펙티브 자바 item 1, 2 블로그 포스팅"},{"excerpt":"이전부터 Github에 있는 Issue와 Projects 기능을 사용해서 프로젝트를 체계적으로 관리해보고 싶었다. 그래서 현재 진행하고 있는  개인 프로젝트에 적용해보기로 했다. Projects Projects 기능을 사용하여 프로젝트의 작업 현황과 진행도를 알 수 있고, 쉽게 관리 가능하다. 내가 생성한 프로젝트를 관리할 수 있는 칸반 보드라고 생각하면…","fields":{"slug":"/2022-04-27-using-github-projects/"},"frontmatter":{"date":"April 27, 2022","title":"Github Project 기능으로 프로젝트 관리하기","tags":["Github"]},"rawMarkdownBody":"\r\n이전부터 Github에 있는 Issue와 Projects 기능을 사용해서 프로젝트를 체계적으로 관리해보고 싶었다. 그래서 현재 진행하고 있는 `Studier` 개인 프로젝트에 적용해보기로 했다.\r\n\r\n### Projects\r\nProjects 기능을 사용하여 프로젝트의 작업 현황과 진행도를 알 수 있고, 쉽게 관리 가능하다. 내가 생성한 프로젝트를 관리할 수 있는 칸반 보드라고 생각하면 좋다.\r\n\r\n### 1. Project 생성하기\r\n\r\nProjects 기능을 사용해서 Issue와 연동시켜보자.\r\n\r\n![](project_list.png)\r\nNew Project를 클릭한다.\r\n\r\n\r\n![](2_new_project.png)\r\n프로젝트 정보(board 이름, 설명)를 기입하면 된다.\r\n\r\n\r\n![](3_select_project_template.png)\r\n템플릿은 `Automated kanban`으로 선택한다. 그래야 Issue와 Pull Request 생성/수정/삭제 시 프로젝트 탭에서도 자동적으로 반영이 가능하다.\r\n\r\n\r\n![](4_project_column_list.png)\r\n프로젝트 생성 완료 후, 생성이 된 프로젝트를 볼 수 있다.\r\n\r\n`To do`, `In progress`, `Done`으로 나누어지며, 직접 항목을 구성해볼 수도 있다. \r\n- To do\r\n  - 작업을 새로 올렸을 때\r\n  - Issue나 Pull Request를 새로 추가할 때\r\n- In progress\r\n  - 작업을 진행 중일 때\r\n  - Issue나 Pull Request를 Open했을 때\r\n- Done\r\n  - 작업을 완료했을 때\r\n  - Issue나 Pull Request를 Close했을 때\r\n\r\n### 2. Issue 올리기\r\nIssue를 새로 추가해 좀 전에 만든 Project에 자동적으로 생성될 수 있도록 하자.\r\n\r\n![](6_new_issue.png)\r\n다른 부분에는 올릴 이슈에 관한 내용을 올리면 되고, 오른쪽 패널 부분을 보면 Label와 Projects이 있다.\r\n\r\n\r\n![](7_select_labels.png)\r\nLabels는 작업의 성격을 태그 형태로 달 수 있는 기능이며, 필수 사항은 아니다.\r\n\r\n나의 경우, Labels 설명 그대로 문서를 관리하게 될 때는 `documentation`, 새로운 기능을 올릴 때는 `inhancement`를 사용했다.\r\n\r\n\r\n![](8_select_project.png)\r\n앞서 생성한 프로젝트와 연동한 경우에는, Projects에 프로젝트를 선택해주면 된다.\r\n\r\n### 예시\r\n![](9_project_ex.png)\r\n`Studier` 프로젝트에서 진행될 항목을 Issue에 올린 결과이다.\r\n\r\n프로젝트 진행 사항을 한 눈에 볼 수 있고, Label을 통해 진행할 작업의 성격을 쉽게 알 수 있다.\r\n\r\n앞으로 이 기능을 사용하여 프로젝트를 체계적으로 관리할 것이며, 추후 팀 프로젝트에도 적용해보고 싶다.\r\n\r\n### 참고\r\n- [협업 시 프로젝트(Projects)와 이슈(Issue) 사용하기](https://devlog-wjdrbs96.tistory.com/227)"},{"excerpt":"이번 주 계획 이행 JPA 강의 끝내기 ⭕ 토이프로젝트 메인 화면 구현 ⭕ 토이프로젝트 필요한 API 정리 ❌ '부의 추월차선' 책 270페이지까지 읽기 ⭕ 블로그 글 짧게 2번 포스팅하기 ❌ 커밋 스터디 5번 인증하기 ❌ 해낸 일 JPA 개념 강의를 드디어 끝냈다 계속 미뤘던 JPA 강의를 끝냈다. 개념 강의여서 그런지 진도가 빠르게 나가지 않았는데, …","fields":{"slug":"/2022-04-24-weekly-report/"},"frontmatter":{"date":"April 24, 2022","title":"4월 넷째주 주간 회고","tags":["회고"]},"rawMarkdownBody":"\r\n### 이번 주 계획 이행\r\n- JPA 강의 끝내기 ⭕\r\n- 토이프로젝트 메인 화면 구현 ⭕\r\n- 토이프로젝트 필요한 API 정리 ❌\r\n- '부의 추월차선' 책 270페이지까지 읽기 ⭕\r\n- 블로그 글 짧게 2번 포스팅하기 ❌\r\n- 커밋 스터디 5번 인증하기 ❌\r\n\r\n### 해낸 일\r\n\r\n- JPA 개념 강의를 드디어 끝냈다\r\n  - 계속 미뤘던 JPA 강의를 끝냈다. 개념 강의여서 그런지 진도가 빠르게 나가지 않았는데, 이번 주는 진짜 작정하고 다 듣는 것을 목표로 계속 강의를 들었다. JPA 개념을 확실하게 익힐 수 있어서 유익한 강의였다. 다음에는 [Spring Boot와 JPA 활용 강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1)와 [Spring Data JPA 강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84)를 병행하며 Spring Boot 프로젝트에 Spring Data JPA를 사용해서 적용하는 방법을 배울 것이다.\r\n\r\n- 운동을 시작했다\r\n  - 최근 체력의 한계를 느끼기도 했고, 하고 있던 미라클모닝&생활 모임에서 '습관으로 만들고 싶은 것'에 관한 이야기를 나누게 되어서 운동을 습관으로 만들어야겠다고 다짐하게 되었다. 그래서 가장 간단하면서도 진입장벽이 낮은 인터벌 달리기 운동을 하기로 했다. 주 3회 꾸준히 하며 30분을 온전히 달릴 수 있는 체력을 기르는 것이 목표다.\r\n\r\n- 모각코 스터디에 들어갔다\r\n  - 요즘 공부 시간은 늘어났지만 집중하는 시간이 적다는 것을 느끼고 있었는데, 마침 모각코(모여서 각자 코딩) 스터디를 모집하는 것을 보게 되어 들어가게 되었다. 한 번 참여했는데, 확실히 전보다는 집중도 잘 되고 주말에 공부하는 시간도 늘어났다. 그리고 잘 운영되고 있는 스터디에 충원으로 참여하게 된 것이여서, 스터디의 원활한 운영방식에 대해서도 생각하게 되었다. 괜찮은 점은 현재 진행하고 있는 깃 커밋 스터디에도 비슷하게 적용할 예정이다.\r\n  \r\n### 부족했던 점\r\n- 블로그 글을 쓰지 못했다\r\n  - 지난 주에 이어서 이번 주도 회고록만 작성하게 되었다. 문제점을 생각해보니 다른 것들을 하느라 블로그 글을 작성하는 일을 자꾸 미루게 되는 것 같아서, 돌아오는 주에는 블로그 글을 작성하는 시간을 마련해서 짧게라도 글을 작성해볼 것이다.\r\n\r\n### 회사 업무\r\n- 성능 테스트를 완료했다\r\n  - 성능 테스트를 진행하면서 이전에는 고려해보지 못했을 성능적인 측면에 대해서도 생각해보고 해결 방법을 찾아 프로젝트에 적용해볼 수 있었다. \r\n\r\n- Spring Config Server에 대해 배웠다\r\n  - Spring Config Server를 통해 나눠진 프로젝트 별로 설정을 관리하는 방법을 배웠고, 기존에 있던 Spring Config Server 프로젝트에 내가 수정한 설정 파일을 업데이트 했다. 이번 프로젝트를 진행하면서 Eureka, Gateway, Config Server에 대해서 배웠는데, MSA를 조금이나마 알게 되어 좋았다. 이외에도 Bus나 Hystrix 등 MSA에 대해 더 깊게 배우고 싶다.\r\n\r\n### 다음주 계획\r\n- 실전 JPA 강의, Spring Data JPA 강의 듣고 프로젝트 구성\r\n- 토이프로젝트 로그인 화면 구현\r\n- 토이프로젝트 필요한 API 정리\r\n- '부의 추월차선' 책 끝내기\r\n- 블로그 글 짧게 2번 포스팅하기"},{"excerpt":"이번주 계획 이행 JPA 강의 끝내기 ❌ 토이프로젝트 화면 구현 🔺 '부의 추월차선' 책 200페이지까지 읽기 ⭕ 블로그 글 3개 작성 ❌  해낸 일 퇴근길에 책을 읽는 것이 습관이 된 것 같다. 습관이 형성되려면 60일은 있어야 한다고는 하지만, 3주 동안 퇴근길에 책을 조금씩이라도 꾸준하게 읽었더니 퇴근길에 책을 읽는 것이 굉장히 자연스러워졌다. 퇴근…","fields":{"slug":"/2022-04-17-weekly-report/"},"frontmatter":{"date":"April 17, 2022","title":"4월 셋째주 주간 회고","tags":["회고"]},"rawMarkdownBody":"\r\n### 이번주 계획 이행\r\n- JPA 강의 끝내기 ❌\r\n- 토이프로젝트 화면 구현 🔺\r\n- '부의 추월차선' 책 200페이지까지 읽기 ⭕\r\n- 블로그 글 3개 작성 ❌ \r\n\r\n### 해낸 일\r\n- 퇴근길에 책을 읽는 것이 습관이 된 것 같다. 습관이 형성되려면 60일은 있어야 한다고는 하지만, 3주 동안 퇴근길에 책을 조금씩이라도 꾸준하게 읽었더니 퇴근길에 책을 읽는 것이 굉장히 자연스러워졌다. 퇴근길이 아니더라도 교통수단을 이용할 때는 책을 읽게 되었고, 가끔씩은 버스에서 내릴 때 읽던 책을 내려놔야해 아쉬운 마음이 들기도 했다. 평소 유튜브나 노래를 들었던 시간을 의미있게 쓸 수 있어서 뿌듯하다. 다른 자투리 시간에도 이렇게 하나씩 의미있는 시간으로 바꿔나가야겠다.\r\n\r\n### 회사 업무\r\n- 이번주는 성능 테스트만 계속해서 진행되었다. `성능 테스트 진행 -> 수정 -> 다시 테스트 진행` 이 과정만 반복된 듯하다. Redis를 도입했었는데 서버를 분리했을 때 데이터가 동기화가 잘 되지 않아서 다양한 경우를 두고 성능테스트를 진행하였다. 그런데 정확한 원인은 잘 모르겠지만, 테스트 측정이 제대로 되지 않는 것 같아서 다음주에도 성능 테스트가 지속될 예정이다.\r\n\r\n- 저년차에 하면 좋을 것들에 관한 [유튜브 영상](https://www.youtube.com/watch?v=eeRwHpMPbJc)을 보았다. 각자도생하며 스스로의 가치를 성장시켜야한다는 내용이었다. 회사에 취업했다고 끝이 아닌 스스로를 성장시켜야 한다는 내용에 크게 공감했다. 현재 생활에 안주하지 않고 더 큰 목표를 위해 나아가야겠다고 다시 한 번 다짐할 수 있는 계기가 되었다.\r\n\r\n### 부족했던 점\r\n- 시간을 잘 쓰지 못했다. 계획한 일들은 많은데 너무 쉽게 지친 것 같다. 바쁘다는 핑계로 JPA 강의도 다 듣지 못했고, 3주째 진행되던 깃허브 커밋 스터디도 최소 기준인 1주일 4회 인증만 맞추었다. 다른 사람들에게 피해를 끼친 것은 아니지만, 3주 전 열심히 하던 때의 의욕이 요즘은 조금 사라진 것 같다. 돌아오는 월요일부터 목표도 가시화하고, 재정비하며 열정을 되찾자🔥\r\n\r\n- 블로그 글을 쓰지 못했다. 이번 주에 3개 작성을 목표로 했는데 현재 쓰고 있는 회고만 작성하게 되었다. 원인을 생각해보니 포스팅하는 것을 너무 거창하게만 생각해 자꾸 미루게 된 것 같다. 단순하고 짧은 글을 자주 작성하는 것을 목표로 이번주에 2개를 작성해봐야겠다.\r\n\r\n### 다음주 계획\r\n- [JPA 강의](https://www.inflearn.com/course/ORM-JPA-Basic) 끝내기🔥\r\n- 토이프로젝트 메인 화면 구현\r\n- 토이프로젝트 필요한 API 정리\r\n- '부의 추월차선' 책 270페이지까지 읽기\r\n- 블로그 글 짧게 2번 포스팅하기\r\n- 커밋 스터디 5번 인증하기"},{"excerpt":"이번주 계획 이행 JPA 강의 끝내기 토이프로젝트 기획, DB 설계하기 '부의 추월차선' 책 150페이지까지 읽기 이펙티브 자바 스터디 예습 미루지 말고 미리 하기 해낸 일 하루도 빠지지 않고 퇴근길에 책을 읽었다. 정말 귀찮게 느껴질 때도 있었지만 '한 페이지만이라도 읽자'라는 마인드로 책을 읽었다. 역시 시작하는게 중요한 것 같다. 회사 업무 프로젝트…","fields":{"slug":"/2022-04-10-weekly-report/"},"frontmatter":{"date":"April 10, 2022","title":"4월 둘째주 주간 회고","tags":["회고"]},"rawMarkdownBody":"\r\n### 이번주 계획 이행\r\n- JPA 강의 끝내기\r\n- ~~토이프로젝트 기획, DB 설계하기~~\r\n- ~~'부의 추월차선' 책 150페이지까지 읽기~~\r\n- ~~이펙티브 자바 스터디 예습 미루지 말고 미리 하기~~\r\n\r\n### 해낸 일\r\n- **하루도 빠지지 않고** 퇴근길에 **책**을 읽었다. 정말 귀찮게 느껴질 때도 있었지만 '한 페이지만이라도 읽자'라는 마인드로 책을 읽었다. 역시 시작하는게 중요한 것 같다.\r\n\r\n### 회사 업무\r\n- 프로젝트에 성능 향상을 위해 Redis를 도입했는데 성능이 실제로 향상되었는지 확인하기 위해서 성능테스트를 진행했다. JMeter 사용 방법을 배우고 테스트를 하면서, 이용자가 빈번하게 사용하여 insert와 update가 자주 발생되는 기능에 한해서는 Redis를 도입하는 것이 실제 성능 향상에 도움이 될 수 있음을 확인해볼 수 있었다.\r\n\r\n- 질문을 열심히 했다. 최근에 유튜브 영상을 보면서 내가 하고 있는 일에 대해 공유하고 질문도 하며 적극적인 태도를 보여야 함을 깨닫기도 했고, 일을 알려주시는 팀원분께서 질문을 자주해도 된다는 말도 해주셔서 모르는 부분에 대해서는 혼자 삽질하며 시간을 길게 끌지 않고 적극적인 태도로 질문하려고 노력했다. \r\n\r\n### 부족했던 점\r\n- 이번주에 약속이 많아서 계획했던 것들을 다 하지 못했다.\r\n- 약속이 아니더라도 일을 쉽게 미뤘던 경향이 있다. 조금 더 부지런해보자.\r\n- 블로그에 글을 많이 작성하지 못했다. 주간 회고를 포함해 2개인데, 더 많이 작성하고 싶다. 생각해둔 것이 여러 개 있으니 좀 더 자주 글을 쓰자.\r\n\r\n### 다음주 계획\r\n- [JPA 강의](https://www.inflearn.com/course/ORM-JPA-Basic) 끝내기🔥\r\n- 토이프로젝트 화면 구현\r\n- '부의 추월차선' 책 200페이지까지 읽기\r\n- 블로그 글 3개 작성"},{"excerpt":"기획 저번 주제 선정 때 주요 기능을 적긴 했지만 기획을 하면서 이번에 개발 할 기능을 다시 정리해보았다. 기본적인 기능을 먼저 개발해야한다고 생각하여 주요 기능을 복잡하지 않게 설계하였다. UI 구성은 카카오 오븐을 이용해서 구현했다. PPT처럼 주어진 도형을 활용해 드래그로 화면을 구성해볼 수 있어 간편하게 사용이 가능하다.  대략적인 구조만 나타냈으…","fields":{"slug":"/2022-04-07-studier-project-plan/"},"frontmatter":{"date":"April 07, 2022","title":"스터디 관리 웹 프로젝트 기획 및 DB 설계","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n### 기획\r\n저번 주제 선정 때 주요 기능을 적긴 했지만 기획을 하면서 이번에 개발 할 기능을 다시 정리해보았다. 기본적인 기능을 먼저 개발해야한다고 생각하여 주요 기능을 복잡하지 않게 설계하였다.\r\n\r\nUI 구성은 [카카오 오븐](https://ovenapp.io/)을 이용해서 구현했다. PPT처럼 주어진 도형을 활용해 드래그로 화면을 구성해볼 수 있어 간편하게 사용이 가능하다. \r\n\r\n대략적인 구조만 나타냈으며, 개발을 진행하면서 Bootstrap을 이용하여 구체적인 부분도 나타낼 것이다.\r\n\r\n#### 1. Login\r\n- 회원 가입\r\n- 로그인\r\n- 로그아웃\r\n\r\n![](studier_login.png)\r\n\r\n#### 2. Study List\r\n- 전체 리스트 조회\r\n- 필터링 기능\r\n\r\n![](studier_study_list.png)\r\n\r\n#### 3. My Study\r\n- 내가 속한 스터디 리스트 조회\r\n- 페이징\r\n\r\n![](studier_my_study.png)\r\n\r\n#### 4. My Study Detail\r\n- 선택한 스터디 정보 조회\r\n- 스터디에 속한 멤버 조회\r\n- 일정은 화면만 구성, 일정 기능 구현은 나중에 추가할 예정\r\n\r\n![](studier_study_detail.png)\r\n\r\n#### 5. Study Post\r\n- 스터디 내 글쓰기 기능\r\n- 글 조회/추가/수정/삭제\r\n\r\n![](studier_study_post.png)\r\n\r\n\r\n#### 6. Study Post Detail\r\n- 글 조회\r\n\r\n![](studier_study_post_detail.png)\r\n\r\n\r\n### DB 설계\r\n위의 기능을 토대로 DB를 설계하였다.\r\n\r\n![](studier_db.jpg)"},{"excerpt":"해낸 일 이번 주에 깃허브 1일 1커밋 스터디를 시작했다. 스터디 시작 이후 블로그도 다시 재개했고, 휑했던 잔디도 다시 채워져가고 있다. 개발 공부 시간도 훨씬 많아져 스터디 만들길 잘했다고 생각하고 있다. 목표는 한달로 잡았는데, 목표를 넘어 꾸준히 습관으로 자리잡고 싶다. 위의 연장선상으로 블로그에 글을 2개(지금 작성하고 있는 주간회고까지 포함하면…","fields":{"slug":"/2022-04-03-weekly-report/"},"frontmatter":{"date":"April 03, 2022","title":"4월 첫째주 주간 회고","tags":["회고"]},"rawMarkdownBody":"\r\n### 해낸 일\r\n- 이번 주에 **깃허브 1일 1커밋 스터디를 시작**했다. 스터디 시작 이후 블로그도 다시 재개했고, 휑했던 잔디도 다시 채워져가고 있다. 개발 공부 시간도 훨씬 많아져 스터디 만들길 잘했다고 생각하고 있다. 목표는 한달로 잡았는데, 목표를 넘어 꾸준히 습관으로 자리잡고 싶다.\r\n\r\n- 위의 연장선상으로 **블로그에 글을 2개**(지금 작성하고 있는 주간회고까지 포함하면 3개) **작성**했다. 앞으로 글을 자주 작성해서 기록을 남기는 사람이 되자.\r\n\r\n- **주말에 공부**했다. 항상 평일에는 열심히만 살다가 체력 부족으로 주말만 가면 늘어지는 생활을 반복했다. 주말 시간이 평일보다 더 긴데, 이를 잘 활용하지 못했었다. 이번주 주말에는 JPA 강의를 듣고 공부를 했다. 평일보다 여유롭고 더 많은 내용을 공부할 수 있어서 좋았다. 주말에 공부하는 것을 습관으로 만들자.\r\n\r\n- 퇴근길에 조금씩 **독서**를 했다. 1월부터 꾸준히 하고 있는 미라클모닝&생활 모임이 있는데, 거기에서 퇴근길에 독서하시는 분이 계셔서 좋은 마음으로 따라했다. 평소에 책 읽을 시간이 없다고 생각했는데, 퇴근 시간에 유튜브나 노래를 듣는 대신 책을 읽으니 본래 시간을 사용하지 않으면서 책을 한 권 읽을 수 있어서 뿌듯했다. 현재는 '부의 추월차선'을 읽고 있다. 부를 좀 더 빨리 만들기 위한 마음가짐에 대해 배우고 있다. \r\n\r\n### 회사 업무\r\n- 새로운 프로젝트를 최근에 맡아서 신입으로서 열심히 배우고 있다. 프로젝트에 필요한 Spring Data JPA, MSA 구조, Spring Cloud Gateway, Redis, Cache에 관해 새롭게 배우게 되었다. 이론적인 지식을 가지고 있지 않은 상태에서 접하게 되어 진도가 느리고 기초적인 질문도 많았지만 잘 알려주셔서 감사할 따름이다.\r\n배우면서 아직 부족한 점이 많음을 느꼈고, 얼른 배워서 성장하고 싶다.\r\n\r\n- 회사 생활에 관한 좋은 [유튜브 영상](https://www.youtube.com/watch?v=NqXFSuEuRKI)을 발견했다. 회사 생활을 하면서 가져야할 마인드에 대한 내용이었는데, 기존에 내가 가지고 있던 관점과 전혀 다른 관점이었다. 말씀하신 내용 중 안 좋은 태도나 습관 예시가 나와 비슷해 놀랍기도 했다. 내 단점보다는 장점을 찾고 이를 증명하려 노력해야겠다는 깨달음을 얻었다. 나중에 책 '나답게 일한다는 것'도 읽어봐야겠다.\r\n\r\n### 부족했던 점\r\n- 질문을 더 많이 하고, 다른 사람과 공유하는 태도를 가지자.\r\n- 버리는 시간이 아직도 많다. 그 시간을 좀 더 활용해보자.\r\n- 계획을 세우고 잘 지키자. 매번 계획을 초반에 세우기만 하고 나중가면 흐지부지 된다. 꾸준함은 좋은 무기가 되니 꾸준하게 하자.\r\n\r\n### 다음주 계획\r\n- [JPA 강의](https://www.inflearn.com/course/ORM-JPA-Basic) 끝내기\r\n- 토이프로젝트 기획, DB 설계하기\r\n- '부의 추월차선' 책 150페이지까지 읽기\r\n- 이펙티브 자바 스터디 예습 미루지 말고 미리 하기"},{"excerpt":"스프링부트 프로젝트를 간단하게 생성해보자. 1. Spring Initializr 홈페이지 들어가기 Spring Initializr에 들어가면 스프링부트 프로젝트를 생성할 수 있다. 2. 프로젝트 정보 입력 \n 개발할 프로젝트에 관해 정보를 입력하면 된다. Project Maven, Gradle은 프로젝트 라이브러리 및 빌드를 관리할 수 있는 툴이다. Gr…","fields":{"slug":"/2022-04-02-spring-boot-initial/"},"frontmatter":{"date":"April 02, 2022","title":"Spring boot 프로젝트 만들기","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n스프링부트 프로젝트를 간단하게 생성해보자.\r\n\r\n### 1. Spring Initializr 홈페이지 들어가기\r\n[Spring Initializr](https://start.spring.io/)에 들어가면 스프링부트 프로젝트를 생성할 수 있다.\r\n\r\n### 2. 프로젝트 정보 입력\r\n![](1.png)\r\n![](4.png)\r\n\r\n개발할 프로젝트에 관해 정보를 입력하면 된다.\r\n\r\n#### Project\r\nMaven, Gradle은 프로젝트 라이브러리 및 빌드를 관리할 수 있는 툴이다. Gradle이 더 간편하기 때문에 요즘 많이 사용되고 있다. 나는 `Gradle Project`로 지정하였다.\r\n\r\n#### Language\r\n자바 프로젝트이기 때문에 Java를 선택했다.\r\n\r\n#### Spring Boot Version\r\n선택할 수 있는 버전이 다양한데, `SNAPSHOT`은 현재 개발 중인 버전, `M`은 정식으로 릴리즈되지 않은 버전이다.\r\n아무것도 붙어있지 않은 버전이 정식 릴리즈된 버전이므로, 정식 릴리즈 버전 중 가장 최신 버전을 선택하였다.\r\n\r\n#### Project Metadata\r\n프로젝트 이름을 지정하면 된다. `Group`은 보통 기업 도메인명, `Artifact`는 빌드 결과물 이름을 작성하는데, 개인 프로젝트의 경우에는 `Group`은 블로그나 본인을 식별할 수 있는 이름으로, `Artifact`는 프로젝트 이름으로 지정하면 된다.\r\n\r\n### 3. Dependency 추가\r\n추가할 라이브러리 및 툴 등을 선택하는 항목이다.\r\n\r\n![](3.png)\r\n\r\n내가 추가한 항목은 다음과 같다.\r\n- `Spring Web`\r\n- `Spring Data JPA` : JPA를 편리하게 사용할 수 있는 기능\r\n- `Spring Security` : 스프링 기반 보안 및 인증 담당\r\n- `Lombok` : Getter와 Setter, Constructor를 어노테이션으로 간편하게 만들어주는 기능\r\n- `MySQL Driver`\r\n- `Thymeleaf` : Controller가 전달하는 데이터를 View에서 동적으로 화면을 구성할 수 있도록 하는 템플릿\r\n\r\n여기서 선택할 수도 있지만 프로젝트 생성 후에도 build.gradle 파일에서 Dependency를 추가할 수 있다.\r\n\r\n### 프로젝트 파일 생성하기\r\n![](5.png)\r\n\r\n모든 정보 및 의존성을 추가하면, GENERATE 버튼을 눌러 프로젝트를 생성하면 된다. 그러면 .zip파일로 프로젝트 파일이 생성이 되고 파일을 압축해제해 사용하면 된다."},{"excerpt":"아직 제대로된 프로젝트를 만들어본 적이 없다는 생각이 들었다. 간단하게만 만들어보고 방치해 둔 프로젝트가 많아 깃허브에서도 다른 사람에게 설명을 할 때도 프로젝트 경험을 자신있게 말하기 힘들었다. 어쩌면 부족할 수도 있겠지만, 이번 기회에 해보고 싶은 것을 하나씩 하며 부족한 지식을 채워나가고 싶다. 블로그에 프로젝트 과정을 기록해보는 것도 처음이어서 문…","fields":{"slug":"/2022-04-01-studier-project-ready/"},"frontmatter":{"date":"April 01, 2022","title":"스터디 관리 웹 프로젝트 준비","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n\r\n아직 제대로된 프로젝트를 만들어본 적이 없다는 생각이 들었다. 간단하게만 만들어보고 방치해 둔 프로젝트가 많아 깃허브에서도 다른 사람에게 설명을 할 때도 프로젝트 경험을 자신있게 말하기 힘들었다. 어쩌면 부족할 수도 있겠지만, 이번 기회에 해보고 싶은 것을 하나씩 하며 부족한 지식을 채워나가고 싶다.\r\n\r\n블로그에 프로젝트 과정을 기록해보는 것도 처음이어서 문장이 어색할 수도 있고 잘못된 용어나 지식을 사용할 수도 있지만, 꾸준히 기록하는 것을 목표로 차근차근 해나가려 한다.\r\n\r\n### 주제 선정\r\n\r\n꾸준한 프로젝트 진행을 위해서는 내가 관심있어하고 나에게 필요한 주제로 프로젝트를 진행해야겠다고 생각했다. 최근 여러 스터디를 진행하고 참여하면서, 스터디를 한데 모아서 관리할 수 있는 시스템이 있으면 좋겠다고 생각해서 **스터디 관리 웹사이트**를 주제로 선정했다. \r\n\r\n### 기능\r\n\r\n일단 기본적인 기능은 다음과 같이 생각했으며, 추후 점차적으로 기능을 붙여나갈 계획이다.\r\n\r\n1. 스터디 관리\r\n    - 스터디 정보 조회\r\n    - 스터디 공지 관리\r\n    - 일정 관리\r\n    - 과제(인증) 관리\r\n2. 회원 관리\r\n    - 로그인\r\n    - 스터디 별 멤버 관리\r\n    - 스터디 별 권한 관리(스터디장만 공지글 작성)\r\n3. 관리자 페이지\r\n    - 관리자 로그인\r\n    - 에러 관리 로그\r\n    - 로그인 로그\r\n\r\n추후 추가하고 싶은 기능\r\n\r\n1. 스터디 모집 관리\r\n2. 기록 기능\r\n\r\n### 기술 스택\r\n\r\nSpring Boot, JPA, MySQL, Spring Security, OAuth, JUnit, AWS, Jenkins\r\n\r\n백엔드 개발을 중심으로 진행할 것이기 때문에 프론트 단은 간단하게 부트스트랩으로 나타낼 것이다. 그리고 AWS와 Jenkins는 아직 제대로 경험해본 적이 없지만 이번 프로젝트를 통해 배워갈 예정이다."},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/12982 문제 설명 S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구…","fields":{"slug":"/2021-12-09-algorithm-programmers-31/"},"frontmatter":{"date":"December 09, 2021","title":"[프로그래머스] 예산","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/12982>\r\n\r\n### 문제 설명\r\n\r\nS사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.\r\n\r\n물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.\r\n\r\n부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.\r\n- d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.\r\n- budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n|d|budget|result|\r\n|-|-|-|\r\n|[1,3,2,5,4]|9|3|\r\n|[2,2,3,3]|10|4|\r\n\r\n#### 입출력 예 #1\r\n\r\n각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.\r\n\r\n- 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.\r\n- 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n- 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.\r\n- 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.\r\n\r\n3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n#### 입출력 예 #2\r\n\r\n모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.\r\n\r\n### 내 풀이\r\n\r\n최대한 많은 부서의 물품을 구매해줄 수 있도록 해야하기 때문에 금액이 적은 부서 순으로 선택해야 한다고 생각했고, 문제를 아래와 같이 나눴다.\r\n\r\n1. 배열 d 정렬하기\r\n2. 배열 d를 왼쪽부터 더하면서 budget을 넘지 않는 선을 구하기\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int[] d, int budget) {\r\n        int answer = 0;\r\n        Arrays.sort(d);\r\n        int sum = 0;\r\n        for (int n : d) {\r\n            sum += n;\r\n            if(sum > budget) {\r\n                return answer;\r\n            }\r\n            answer++;\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\nd가 배열이어서 간단하게 `Arrays.sort`로 정렬했는데, `Collections.sort`나 Comparable 인터페이스 등 Java에서 정렬하는 방법이 다양하기 때문에 이는 따로 정리를 해야겠다.\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/12977 문제 설명 주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 re…","fields":{"slug":"/2021-12-07-algorithm-programmers-30/"},"frontmatter":{"date":"December 07, 2021","title":"[프로그래머스] 소수 만들기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/12977>\r\n\r\n### 문제 설명\r\n\r\n주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.\r\n- nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.\r\n\r\n### 입출력 예\r\n\r\n|nums|result|\r\n|-|-|\r\n|[1,2,3,4]|1|\r\n|[1,2,7,6,4]|4|\r\n\r\n#### 입출력 예 #1\r\n\r\n- [1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n\r\n#### 입출력 예 #2\r\n\r\n- [1,2,4]를 이용해서 7을 만들 수 있습니다.\r\n- [1,4,6]을 이용해서 11을 만들 수 있습니다.\r\n- [2,4,7]을 이용해서 13을 만들 수 있습니다.\r\n- [4,6,7]을 이용해서 17을 만들 수 있습니다.\r\n\r\n### 내 풀이\r\n\r\n주어진 숫자 중에서 3개를 더했을 때 소수가 되는 경우의 개수를 구하므로 문제를 아래와 같이 나눌 수 있다.\r\n\r\n1. nums 배열에서 숫자 3개를 선택하기\r\n2. 소수를 찾아서 카운팅하기 \r\n\r\n1번의 방법은 다양하지만 선택하는 수가 3개로 정해져 있기 때문에 for문을 세 번 사용해서 구현했다. \r\n\r\n\r\n```java\r\nclass Solution {\r\n    \r\n    public boolean isPrime(int n) {\r\n        for (int i = 2; i*i <= n; i++) {\r\n            for (int j = i; j < n; j+=i) {\r\n                if (n % j == 0) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    public int solution(int[] nums) {\r\n        int answer = 0;\r\n\r\n        for (int i=0; i<nums.length - 2; i++) {\r\n            for (int j=i+1; j<nums.length - 1; j++) {\r\n                for (int k=j+1; k<nums.length; k++) {\r\n                    int sum = nums[i] + nums[j] + nums[k];\r\n                    if (isPrime(sum)) {\r\n                        answer++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n### 보완점\r\n\r\n소수 찾는 과정에서 에라토스테네스 체 구현 방법과 혼동되어 불필요한 한 줄을 더하게 되었다. 오히려 시간복잡도가 증가하기 때문에 이를 보완하면 다음과 같다.\r\n\r\n```java\r\nclass Solution {\r\n    \r\n    public boolean isPrime(int n) {\r\n        for (int i = 2; i*i <= n; i++) {\r\n            if (n % i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    public int solution(int[] nums) {\r\n        int answer = 0;\r\n\r\n        for (int i=0; i<nums.length - 2; i++) {\r\n            for (int j=i+1; j<nums.length - 1; j++) {\r\n                for (int k=j+1; k<nums.length; k++) {\r\n                    int sum = nums[i] + nums[j] + nums[k];\r\n                    if (isPrime(sum)) {\r\n                        answer++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n다음에는 숫자 3개를 선택하는 과정에서, for 문을 여러번 사용한 부분을 다른 방식으로도 수정해봐야겠다."},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/70129 문제 설명 0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다. x의 모든 0을 제거합니다.\nx의 길이를 c라고 하면, x를 \"c를 2진법으로 표현한 문자열\"로 바꿉니다.\n예를 들어, 이라면, x에 이진 변환을 가하면…","fields":{"slug":"/2021-07-25-algorithm-programmers-27/"},"frontmatter":{"date":"July 25, 2021","title":"[프로그래머스] 이진 변환 반복하기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/70129>\r\n\r\n### 문제 설명\r\n\r\n0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.\r\n\r\nx의 모든 0을 제거합니다.\r\nx의 길이를 c라고 하면, x를 \"c를 2진법으로 표현한 문자열\"로 바꿉니다.\r\n예를 들어, `x = \"0111010\"`이라면, x에 이진 변환을 가하면 `x = \"0111010\" -> \"1111\" -> \"100\"` 이 됩니다.\r\n\r\n0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 \"1\"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- s의 길이는 1 이상 150,000 이하입니다.\r\n- s에는 '1'이 최소 하나 이상 포함되어 있습니다.\r\n\r\n### 입출력 예\r\n\r\n|s|result|\r\n|-|-|\r\n|\"110010101001\"|[3,8]|\r\n|\"01110\"|[3,3]|\r\n|\"1111111\"|[4,1]|\r\n\r\n#### 입출력 예 #1\r\n\r\n- \"110010101001\"이 \"1\"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.\r\n\r\n|회차|이진 변환 이전|제거할 0의 개수|0 제거 후 길이|이진 변환 결과|\r\n|-|-|-|-|-|\r\n|1|\"110010101001\"|6|6|\"110\"|\r\n|2|\"110\"|1|2|\"10\"|\r\n|3|\"10\"|1|1|\"1\"|\r\n\r\n- 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, `[3,8]`을 return 해야 합니다.\r\n\r\n#### 입출력 예 #2\r\n\r\n- \"01110\"이 \"1\"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.\r\n\r\n|회차|이진 변환 이전|제거할 0의 개수|0 제거 후 길이|이진 변환 결과|\r\n|-|-|-|-|-|\r\n|1|\"01110\"|2|3|\"11\"|\r\n|2|\"11\"|0|2|\"10\"|\r\n|3|\"10\"|1|1|\"1\"|\r\n\r\n- 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.\r\n\r\n#### 입출력 예 #3\r\n\r\n- \"1111111\"이 \"1\"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.\r\n\r\n|회차|이진 변환 이전|제거할 0의 개수|0 제거 후 길이|이진 변환 결과|\r\n|-|-|-|-|-|\r\n|1|\"1111111\"|0|7|\"111\"|\r\n|2|\"111\"|0|3|\"11\"|\r\n|3|\"11\"|0|2|\"10\"|\r\n|4|\"10\"|1|1|\"1\"|\r\n\r\n- 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.\r\n\r\n### 내 풀이\r\n\r\n문제에서 진행되는 순서대로 구현하면 된다. s에서 1의 개수를 세서, 그 개수를 이진수로 변환하면 된다.\r\n\r\n나는 이진수로 변환하는 과정을 직접 구현했는데, 다른 사람의 풀이를 보니 `Integer.toBinaryString(n);`을 사용해 간단하게 이진수로 변환했다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int[] solution(String s) {\r\n        int[] answer = new int[2];\r\n        int countZero = 0;\r\n        int count = 0;\r\n        while(!s.equals(\"1\")) {\r\n            int n = 0;\r\n            for (int i=0; i<s.length(); i++) {\r\n                if (s.charAt(i) == '1') {\r\n                    n++;\r\n                }\r\n            }\r\n            countZero += s.length() - n;\r\n            \r\n            String binary = \"\";\r\n            while(n != 0) {\r\n                binary += n % 2;\r\n                n /= 2;\r\n            }\r\n            s = \"\";\r\n            for (int i=binary.length() - 1; i>=0; i--) {\r\n                s += binary.charAt(i);\r\n            }\r\n            count++;\r\n        }\r\n        answer[0] = count;\r\n        answer[1] = countZero;\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/68936 문제 설명 0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.…","fields":{"slug":"/2021-07-25-algorithm-programmers-28/"},"frontmatter":{"date":"July 25, 2021","title":"[프로그래머스] 쿼드 압축 후 개수 세기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/68936>\r\n\r\n### 문제 설명\r\n\r\n0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.\r\n\r\n1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.\r\n2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.\r\n3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.\r\n\r\narr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.\r\n    - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.\r\n    - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.\r\n\r\n### 입출력 예\r\n\r\n|arr|result|\r\n|-|-|\r\n|[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]|[4,9]|\r\n|[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]|[10,15]|\r\n\r\n#### 입출력 예 #1\r\n\r\n- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.\r\n- ![예1]({{\"/assets/images/algorithm-programmers-28-1.png\"| relative_url}})\r\n- 최종 압축 결과에 0이 4개, 1이 9개 있으므로, [4,9]를 return 해야 합니다.\r\n\r\n#### 입출력 예 #2\r\n\r\n- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.\r\n- ![예2]({{\"/assets/images/algorithm-programmers-28-2.png\"| relative_url}})\r\n- 최종 압축 결과에 0이 10개, 1이 15개 있으므로, [10,15]를 return 해야 합니다.\r\n\r\n### 내 풀이\r\n\r\n```java\r\nclass Solution {\r\n\tint[] answer;\r\n\t\r\n\tpublic void quad(int n, int y, int x, int[][] arr) {\r\n\t\tif(n == 1) {\r\n\t\t\tanswer[arr[y][x]]++;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif(isBlock(n, y, x, arr)) return;\r\n\t\t\r\n\t\tquad(n/2, y, x, arr);\r\n\t\tquad(n/2, y + n/2, x, arr);\r\n\t\tquad(n/2, y, x + n/2, arr);\r\n\t\tquad(n/2, y + n/2, x + n/2, arr);\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic boolean isBlock(int n, int y, int x, int[][] arr) {\r\n\t\tfor (int i = y; i < y + n; i++) {\r\n\t\t\tfor (int j = x; j < x + n; j++) {\r\n\t\t\t\tif(arr[y][x] != arr[i][j]) return false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tanswer[arr[y][x]]++;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic int[] solution(int[][] arr) {\r\n\t\tanswer = new int[2];\r\n\t\tquad(arr.length, 0, 0, arr);\r\n\t\treturn answer;\r\n\t}\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/68645 문제 설명 정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 s…","fields":{"slug":"/2021-07-23-programmers-algorithm-26/"},"frontmatter":{"date":"July 23, 2021","title":"[프로그래머스] 삼각 달팽이","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/68645>\r\n\r\n### 문제 설명\r\n\r\n정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요.\r\n\r\n![68645 image]({{\"/assets/images/algorithm-programmers-26-1.png\"| relative_url}})\r\n\r\n### 제한사항\r\n\r\n- n은 1 이상 1,000 이하입니다.\r\n\r\n\r\n### 입출력 예\r\n\r\n|n|result|\r\n|-|-|\r\n|4|[1,2,9,3,10,8,4,5,6,7]|\r\n|5|[1,2,12,3,13,11,4,14,15,10,5,6,7,8,9]|\r\n|6|[1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11]|\r\n\r\n### 내 풀이\r\n\r\n세 부분으로 나누어 값을 더하고 빼는 방식으로 동일하게 접근했으나, 이 과정에서 반복적으로 나타내는 방법을 제대로 구현하지 못해 다른 사람들의 풀이를 보게되었다.\r\n\r\n삼각 피라미드로 해결하는 것이 아닌, 정사각형으로 보고 삼각형을 왼쪽으로 싹 밀어서 생각하면 훨씬 생각도 쉬워지고 코드도 간단해진다.\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] solution(int n) {\r\n        int[] answer = new int[n * (n+1) / 2];\r\n        int[][] matrix = new int[n][n];\r\n        \r\n        int x = -1, y = 0;\r\n        int num = 1;\r\n        \r\n        // 2차원 배열에 값 삽입\r\n        for (int i=0; i<n; i++) {\r\n            for (int j=i; j<n; j++) {\r\n                if (i % 3 == 0) x++;\r\n                else if (i % 3 == 1) y++;\r\n                else if (i % 3 == 2) { x--; y--; }\r\n                matrix[x][y] = num++;\r\n            }\r\n        }\r\n        \r\n        // 2차원 배열을 1차원 배열로 변경\r\n        int k = 0;\r\n        for (int i=0; i<n; i++) {\r\n            for (int j=0; j<n; j++) {\r\n                if (matrix[i][j] == 0) break;\r\n                answer[k++] = matrix[i][j];\r\n            }\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n### 참고\r\n- https://minhamina.tistory.com/58"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/68644 문제 설명 정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 numb…","fields":{"slug":"/2021-07-18-programmers-algorithm-25/"},"frontmatter":{"date":"July 18, 2021","title":"[프로그래머스] 두 개 뽑아서 더하기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/68644>\r\n\r\n### 문제 설명\r\n\r\n정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- numbers의 길이는 2 이상 100 이하입니다.\r\n    - numbers의 모든 수는 0 이상 100 이하입니다.\r\n\r\n\r\n### 입출력 예\r\n\r\n|numbers|result|\r\n|-|-|\r\n|[2,1,3,4,1]|[2,3,4,5,6,7]|\r\n|[5,0,2,7]|[2,5,7,9,12]|\r\n\r\n#### 입출력 예 #1\r\n\r\n2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)\r\n3 = 2 + 1 입니다.\r\n4 = 1 + 3 입니다.\r\n5 = 1 + 4 = 2 + 3 입니다.\r\n6 = 2 + 4 입니다.\r\n7 = 3 + 4 입니다.\r\n따라서 [2,3,4,5,6,7] 을 return 해야 합니다.\r\n\r\n#### 입출력 예 #2\r\n\r\n2 = 0 + 2 입니다.\r\n5 = 5 + 0 입니다.\r\n7 = 0 + 7 = 5 + 2 입니다.\r\n9 = 2 + 7 입니다.\r\n12 = 5 + 7 입니다.\r\n따라서 [2,5,7,9,12] 를 return 해야 합니다.\r\n\r\n### 내 풀이\r\n\r\nnumbers의 수를 각각 두 개를 뽑아서 더해준 후 정렬하였다.\r\nfor문이 두 개여도 numbers의 길이가 100 이하이기 때문에 시간이 적게 걸리기 때문에 사용할 수 있었다.\r\n\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int[] solution(int[] numbers) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i=0; i<numbers.length - 1; i++) {\r\n            for (int j=i+1; j<numbers.length; j++) {\r\n                int tmp = numbers[i] + numbers[j];\r\n                if(!list.contains(tmp)) {\r\n                    list.add(tmp);\r\n                }\r\n            }\r\n        }\r\n        int[] answer = new int[list.size()];\r\n        Collections.sort(list);\r\n        for (int i=0; i<list.size(); i++) {\r\n            answer[i] = list.get(i);\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/68935 문제 설명 자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 100,000,000 이하인 자연수입니다.…","fields":{"slug":"/2021-07-16-programmers-algorithm-24/"},"frontmatter":{"date":"July 16, 2021","title":"[프로그래머스] 3진법 뒤집기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/68935>\r\n\r\n### 문제 설명\r\n\r\n자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- n은 1 이상 100,000,000 이하인 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n|name|result|\r\n|-|-|\r\n|45|7|\r\n|125|229|\r\n\r\n### 내 풀이\r\n\r\n문제 그대로 n을 3진법을 뒤집은 후, 이를 다시 10진법으로 표현하면 된다.\r\n다만, 3진법을 나타낼 때 뒤에서 부터 나타내 뒤집는 단계를 생략하도록 했다.\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int solution(int n) {\r\n        int answer = 0;\r\n        String str = \"\";\r\n        while (n > 0) {\r\n            str += (n % 3);\r\n            n /= 3;\r\n        }\r\n        for(int i=0; i<str.length(); i++) {\r\n            answer += (str.charAt(str.length() - i - 1) - '0') * (int) Math.pow(3, i);\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"layout: post\ntitle: \"알고리즘 그리디 알고리즘\"\ncategories: Algorithm 그리디 알고리즘(greedy algorithm) 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행해 최종 해답에 도달하는 문제 해결 방식이다. 순간 순간마다의 최선의 결정이 전체 문제에서 최선의 해결책이 되지 않지만…","fields":{"slug":"/2021-07-10-greedy-algorithm/"},"frontmatter":{"date":"July 10, 2021","title":"Greedy Algorithm","tags":["Algorithm"]},"rawMarkdownBody":"\r\n---\r\nlayout: post\r\ntitle: \"[알고리즘] 그리디 알고리즘\"\r\ncategories: [Algorithm]\r\n---\r\n\r\n### 그리디 알고리즘(greedy algorithm)\r\n\r\n문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행해 최종 해답에 도달하는 문제 해결 방식이다.\r\n\r\n순간 순간마다의 최선의 결정이 전체 문제에서 최선의 해결책이 되지 않지만, 몇몇의 문제에서는 최적해를 빠르게 산출해낼 수 있다.\r\n\r\n### 활동 선택 문제\r\n\r\n한 강의실에서 여러 개의 수업을 하려고 할 때 한 번에 가장 많은 수업을 할 수 있는 경우를 고르는 것\r\n\r\nS : 시작 시간, F : 종료 시간\r\n\r\nA1과 A2, A1과 A4는 시간이 겹치기 때문에 동시에 선택 불가\r\nA1과 A3은 선택 가능\r\n-> 이런 식으로 선택해 가장 많은 수업을 할 수 있는 경우를 찾기\r\n\r\n![Greedy Algorithm 1]({{\"/assets/images/greedy-algorithm-1.png\"| relative_url}})\r\n\r\n결과적으로 보면 A1, A3, A6, A8 이나 A1, A3, A7, A9 가 정답\r\n\r\n푸는 방법) G[i, j] = Ai이 종료된 후부터 Aj가 시작하기 전 활동들의 집합, B[i, j] = G[i, j] 중에서 최적의 조합이라고 하면,\r\n\r\nex) G18 = { A3, A5, A6, A7 }, B18 = { A3, A6 } = { A3, A7 }\r\n\r\nC[i, j]를 G[i, j]의 최적 개수를 나타낸다고 하면, C[i, j] = max(C[i, k] + C[k, j] + 1)이고, max는 B18에서 A6 말고 다른 것을 골랐을 때의 경우도 모두 생각해서 그 중 최적을 찾는 것"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42860 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 예를 들어 아래의 방법으로 \"JAZ\"를…","fields":{"slug":"/2021-06-29-algorithm-programmers-23/"},"frontmatter":{"date":"June 29, 2021","title":"[프로그래머스] 조이스틱","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42860>\r\n\r\n### 문제 설명\r\n\r\n조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\r\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\r\n\r\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\r\n\r\n```\r\n▲ - 다음 알파벳\r\n▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)\r\n◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)\r\n▶ - 커서를 오른쪽으로 이동\r\n```\r\n\r\n예를 들어 아래의 방법으로 \"JAZ\"를 만들 수 있습니다.\r\n\r\n```\r\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.\r\n- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.\r\n- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.\r\n```\r\n\r\n따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다.\r\n만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\r\n\r\n\r\n### 제한사항\r\n\r\n- name은 알파벳 대문자로만 이루어져 있습니다.\r\n- name의 길이는 1 이상 20 이하입니다.\r\n\r\n### 입출력 예\r\n\r\n|name|return|\r\n|-|-|\r\n|\"JEROEN\"|56|\r\n|\"JAN\"|23|\r\n\r\n### 내 풀이\r\n\r\n너무 어렵게 생각한 탓에 시간 내에 다 풀지 못하고 다른 사람의 풀이를 참고했다.\r\n내일 다시 한번 풀어보자.\r\n\r\n출처 - [https://hellodavid.tistory.com/4]\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(String name) {\r\n        int answer = 0;\r\n        int len = name.length();\r\n\r\n        // 제일 짧은 좌, 우 이동은 그냥 맨 오른쪽으로 이동할 때\r\n        int min = len - 1;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            // 조이스틱 상, 하 이동\r\n            char c = name.charAt(i);\r\n            int mov = (c - 'A' < 'Z' - c + 1) ? (c - 'A') : ('Z' - c + 1);\r\n            answer += mov;\r\n\r\n            // 조이스틱 좌, 우 이동\r\n            int nextIndex = i + 1;\r\n            // 다음 단어가 A이고, 단어가 끝나기 전까지 nextIndex 증가\r\n            while (nextIndex < len && name.charAt(nextIndex) == 'A')\r\n            nextIndex++;\r\n\r\n            min = Math.min(min, (i * 2) + len - nextIndex);\r\n        }\r\n\r\n        answer += min;\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42862 문제 설명 점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 …","fields":{"slug":"/2021-05-30-algorithm-programmers-22/"},"frontmatter":{"date":"May 30, 2021","title":"[프로그래머스] 체육복","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42862>\r\n\r\n### 문제 설명\r\n\r\n점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\r\n\r\n전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 전체 학생의 수는 2명 이상 30명 이하입니다.\r\n- 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\r\n- 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\r\n- 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\r\n- 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.\r\n\r\n### 입출력 예\r\n\r\n|n|lost|reserve|return|\r\n|-|-|-|-|\r\n|5|[2, 4]|[1, 3, 5]|5|\r\n|5|[2, 4]|[3]|4|\r\n|3|[3]|[1]|2|\r\n\r\n예제 #1\r\n\r\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\r\n\r\n예제 #2\r\n\r\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\r\n\r\n### 내 풀이\r\n\r\n먼저 lost와 reserve 배열을 정렬을 한 후, lost 배열의 i번 학생 왼쪽 학생이 체육복이 있는지 확인하고 그 후 오른쪽 학생의 체육복 소지 여부를 확인한다. 왼쪽 학생을 먼저 확인하는 이유는 학생의 번호를 오름차순으로 탐색하기 때문에 왼쪽을 먼저 선택하는 것이 체육복을 입은 학생의 수가 최대가 된다.\r\n\r\n제한사항에 도난 당한 학생이 있기 때문에 그 부분을 고려해 값이 동일한 학생의 번호를 lost와 reserve에 각각 빼줘야 한다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int n, int[] lost, int[] reserve) {\r\n        Arrays.sort(lost); Arrays.sort(reserve);\r\n        List<Integer> rList = new ArrayList<>();\r\n        List<Integer> lList = new ArrayList<>();\r\n        for (int r : reserve) {\r\n            rList.add(r);\r\n        }\r\n        for (int l : lost) {\r\n            lList.add(l);\r\n        }\r\n        for (int l : lost) {\r\n            if(rList.contains(l)) {\r\n                rList.remove(Integer.valueOf(l));\r\n                lList.remove(Integer.valueOf(l));\r\n            }\r\n        }\r\n        int count = lList.size();\r\n        for (Integer l : lList) {\r\n            if(rList.contains(l - 1)) {\r\n                count--;\r\n                rList.remove(Integer.valueOf(l - 1));\r\n            }\r\n            else if(rList.contains(l + 1)) {\r\n                count--;\r\n                rList.remove(Integer.valueOf(l + 1));\r\n            }\r\n        }\r\n        return n - count;\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42842 문제 설명 Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. 문제 설명 Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는…","fields":{"slug":"/2021-05-28-algorithm-programmers-21/"},"frontmatter":{"date":"May 28, 2021","title":"[프로그래머스] 카펫","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42842>\r\n\r\n### 문제 설명\r\n\r\nLeo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.\r\n\r\n![문제 설명]({{\"/assets/images/algorithm-programmers-21.png\"| relative_url}})\r\n\r\nLeo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.\r\n\r\nLeo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.\r\n- 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.\r\n- 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.\r\n\r\n### 입출력 예\r\n\r\n|brown|yellow|return|\r\n|-|-|-|\r\n|10|2|[4, 3]|\r\n|8|1|[3, 3]|\r\n\r\n### 내 풀이\r\n\r\n`brown + yellow`의 값이 전체 격자의 개수와 같기 때문에 `n`으로 두고, 가로의 개수인 `i`를 3부터 올리면서 n의 약수인지 체크하고, 그 때의 `yellow`와 같은지 확인 후 맞으면 리턴한다.\r\n\r\n```java\r\nclass Solution {\r\n    public int[] solution(int brown, int yellow) {\r\n        int n = brown + yellow;\r\n        for (int i=3; n/i>=3; i++) {\r\n            if (n % i == 0 && yellow == (i - 2) * (n/i - 2)) {\r\n                int[] answer = {(n / i), i};\r\n                return answer;\r\n            }\r\n        }\r\n        return new int[]{};\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42839 문제 설명 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 …","fields":{"slug":"/2021-05-27-algorithm-programmers-20/"},"frontmatter":{"date":"May 27, 2021","title":"[프로그래머스] 소수 찾기","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42839>\r\n\r\n### 문제 설명\r\n\r\n한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\r\n\r\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n\r\n- numbers는 길이 1 이상 7 이하인 문자열입니다.\r\n- numbers는 0~9까지 숫자만으로 이루어져 있습니다.\r\n- \"013\"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.\r\n\r\n### 입출력 예\r\n\r\n|numbers|return|\r\n|-|-|\r\n|\"17\"|3|\r\n|\"011\"|2|\r\n\r\n[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.\r\n[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.\r\n- 11과 011은 같은 숫자로 취급합니다.\r\n\r\n### 내 풀이\r\n\r\n먼저 문자열의 길이가 최대 7이하이므로 문자열로 만들어질 수 있는 최대 수는 `10000000`이므로, 1억까지의 수를 각각 소수인지 아닌지 표시한다.\r\n\r\n소수 배열을 boolean이 아닌 int 타입으로 설정한 이유는 나중에 같은 수의 중복을 막기 위해서다. 순서에 따라 경우의 수가 달라지지만 예제 2번에서 11인 경우 앞뒤가 한 번 바뀌어서 11인 경우도 같은 경우로 취급해줘야 하기 때문에 `np` 배열에 소수를 세었는지 안세었는지도 표시하기 위함이다.\r\n\r\n```java\r\n// 소수 표시, 소수면 0, 소수가 아니면 -1\r\nnp = new int[10000001];\r\nfor (int i=2; i<=10000000; i++) {\r\n    if (np[i] == -1) continue;\r\n    for (int j=i*2; j<=10000000; j+=i) {\r\n        np[j] = -1;\r\n    }\r\n}\r\nnp[0] = np[1] = -1;\r\n```\r\n\r\n이제 조각을 골라야 하는데, 순서가 상관이 있기 때문에 순열을 사용한다.\r\n\r\n`str`은 주어진 `numbers`, `out`은 지금 고른 조각들, `check`은 방문 여부를 체크하는 배열, `depth`는 몇 개 골랐는 지를 나타내는 변수이다.\r\n\r\n처음에는 `out`이 비어있다는 의미로 `\"\"`가 들어가는데, 이걸 예외 처리 해주지 않으면 `np[Integer.valueOf(out)]` 이 부분에서 오류가 생긴다.\r\n\r\n```java\r\npublic static void perm(String str, String out, boolean[] check, int depth, int n) {\r\n    if (!out.equals(\"\") && np[Integer.valueOf(out)] == 0) {\r\n        np[Integer.valueOf(out)]++; // 0이면 1로 만들어서 중복 막기\r\n        answer++;\r\n    }\r\n\r\n    for (int i=0; i<n; i++) {\r\n        if (!check[i]) {\r\n            check[i] = true;\r\n            perm(str, out + str.charAt(i), check, depth + 1, n);\r\n            check[i] = false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nclass Solution {\r\n    static int[] np;\r\n    static int answer;\r\n    \r\n    public int solution(String numbers) {\r\n        answer = 0;\r\n\r\n        // 소수 표시, 소수면 0, 소수가 아니면 -1\r\n        np = new int[10000001];\r\n        for (int i=2; i<=10000000; i++) {\r\n            if (np[i] == -1) continue;\r\n            for (int j=i*2; j<=10000000; j+=i) {\r\n                np[j] = -1;\r\n            }\r\n        }\r\n        np[0] = np[1] = -1;\r\n\r\n        // 조각 고르기 -> 순열\r\n        boolean[] chk = new boolean[numbers.length()];\r\n        perm(numbers, \"\", chk, 0, numbers.length());\r\n\r\n        return answer;\r\n    }\r\n    public static void perm(String str, String out, boolean[] check, int depth, int n) {\r\n        if (!out.equals(\"\") && np[Integer.valueOf(out)] == 0) {\r\n            np[Integer.valueOf(out)]++; // 0이면 1로 만들어서 중복 막기\r\n            answer++;\r\n        }\r\n\r\n        for (int i=0; i<n; i++) {\r\n            if (!check[i]) {\r\n                check[i] = true;\r\n                perm(str, out + str.charAt(i), check, depth + 1, n);\r\n                check[i] = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42840 문제 설명 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3…","fields":{"slug":"/2021-05-26-algorithm-programmers-19/"},"frontmatter":{"date":"May 26, 2021","title":"[프로그래머스] 모의고사","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42840>\r\n\r\n### 문제 설명\r\n\r\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\r\n\r\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r\n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r\n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r\n\r\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한 조건\r\n\r\n시험은 최대 10,000 문제로 구성되어있습니다.\r\n문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\r\n가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\r\n\r\n### 입출력 예\r\n\r\n|answers|return|\r\n|[1,2,3,4,5]|[1]|\r\n|[1,3,2,4,2]|[1,2,3]|\r\n\r\n- 수포자 1은 모든 문제를 맞혔습니다.\r\n- 수포자 2는 모든 문제를 틀렸습니다.\r\n- 수포자 3은 모든 문제를 틀렸습니다.\r\n\r\n따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\r\n\r\n### 내 풀이\r\n\r\n문제를 비교해서 count 배열에 각각 저장하는데, 문제와 찍은 답의 개수가 다르고 찍은 답의 개수가 계속해서 반복되므로 `인덱스 % (찍은 답의 개수)`로 나머지를 구해 정답과 비교한다.\r\n\r\n```java\r\nif (nums.get(j)[i % nums.get(j).length] == answers[i]) count[j]++;\r\n```\r\n\r\ncount 중 가장 높은 수를 `max`에 저장하고, `max`값과 같은 count 값은 가장 많은 문제를 맞힌 사람이므로 answer에 저장한다.\r\n\r\n```java\r\nfor (int i=0; i<3; i++) {\r\n    if (max == count[i]) arr.add(i + 1);\r\n}\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int[] solution(int[] answers) {\r\n        ArrayList<int[]> nums = new ArrayList<>();\r\n        nums.add(new int[] {1, 2, 3, 4, 5});\r\n        nums.add(new int[] {2, 1, 2, 3, 2, 4, 2, 5});\r\n        nums.add(new int[] {3, 3, 1, 1, 2, 2, 4, 4, 5, 5});\r\n        int[] count = new int[3];\r\n        int max = 0;\r\n        for (int j=0; j<3; j++) {\r\n            for (int i=0; i<answers.length; i++) {\r\n                if (nums.get(j)[i % nums.get(j).length] == answers[i]) count[j]++;\r\n            }\r\n            max = Math.max(max, count[j]);\r\n        }\r\n\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        if (max == 0) return new int[] {};\r\n        for (int i=0; i<3; i++) {\r\n            if (max == count[i]) arr.add(i + 1);\r\n        }\r\n        int[] answer = new int[arr.size()];\r\n\r\n        for(int i=0; i<arr.size(); i++) {\r\n            answer[i] = arr.get(i);\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42747 문제 설명 H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 편 중, 번 …","fields":{"slug":"/2021-05-23-algorithm-programmers-18/"},"frontmatter":{"date":"May 23, 2021","title":"[프로그래머스] H-Index","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42747>\r\n\r\n### 문제 설명\r\n\r\nH-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.\r\n\r\n어떤 과학자가 발표한 논문 `n`편 중, `h`번 이상 인용된 논문이 `h`편 이상이고 나머지 논문이 h번 이하 인용되었다면 `h`의 최댓값이 이 과학자의 H-Index입니다.\r\n\r\n어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.\r\n- 논문별 인용 횟수는 0회 이상 10,000회 이하입니다.\r\n\r\n### 입출력 예\r\n\r\n|citations|return|\r\n|-|-|\r\n|[3, 0, 6, 1, 5]|3|\r\n\r\n이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.\r\n\r\n### 내 풀이\r\n\r\n우선 정렬을 해 `[0, 1, 3, 5, 6]`으로 만든다.\r\n\r\n```java\r\nCollections.sort(list);\r\n```\r\n\r\n하나씩 탐색하면서 h편 이하로 인용된 최댓값 h를 구한다.\r\n\r\n```java\r\nint maxH = 0;\r\nint count = 0;\r\nfor (int h=1; h<=list.get(list.size() - 1); h++) {\r\n    for (; count<list.size(); count++) {\r\n        if (h < list.get(count)) break;\r\n    }\r\n    if (h >= count) maxH = Math.max(h, maxH);\r\n}\r\nanswer = maxH;\r\n```\r\n\r\n같은 방법으로 하나씩 탐색하면서 h편 이상으로 인용된 최댓값 h를 구한다.\r\n\r\n```java\r\ncount = list.size();\r\nmaxH = 0;\r\nfor (int h=1; h<=list.get(list.size() - 1); h++) {\r\n    for (int j=list.size() - count; j<list.size(); j++, count--) {\r\n        if (h <= list.get(j)) break;\r\n    }\r\n    if (h <= count) maxH = Math.max(h, maxH);\r\n}\r\nanswer = (maxH < answer) ? maxH : answer;\r\n```\r\n\r\n### 전체 코드\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int[] citations) {\r\n        int answer = 0;\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i : citations) {\r\n            list.add(i);\r\n        }\r\n        Collections.sort(list);\r\n        // h편 이하로 인용된 최댓값 h 구하기\r\n        int maxH = 0;\r\n        int count = 0;\r\n        for (int h=1; h<=list.get(list.size() - 1); h++) {\r\n            for (; count<list.size(); count++) {\r\n                if (h < list.get(count)) break;\r\n            }\r\n            if (h >= count) maxH = Math.max(h, maxH);\r\n        }\r\n        answer = maxH;\r\n        // h편 이상으로 인용된 최댓값 h 구하기\r\n        count = list.size();\r\n        maxH = 0;\r\n        for (int h=1; h<=list.get(list.size() - 1); h++) {\r\n            for (int j=list.size() - count; j<list.size(); j++, count--) {\r\n                if (h <= list.get(j)) break;\r\n            }\r\n            if (h <= count) maxH = Math.max(h, maxH);\r\n        }\r\n        answer = (maxH < answer) ? maxH : answer;\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n### 다른 사람의 풀이\r\n\r\ni가 증가하면서 i보다 높은 오른쪽의 원소들의 개수와 i보다 낮은 왼쪽의 원소들의 개수를 비교해 낮은 값을 가지는 것이 바로 그 때의 h값이 될 것이다.\r\n\r\n그 h값이 가장 최대일 때가 정답값이 된다.\r\n\r\n```java\r\nimport java.util.Arrays;\r\n\r\nclass Solution {\r\n    public int solution(int[] citations) {\r\n        int answer = 0;\r\n        Arrays.sort(citations);\r\n        for(int i=0; i<citations.length; i++){\r\n            int smaller = Math.min(citations[i], citations.length-i);\r\n            answer = Math.max(answer, smaller);\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"Java Collection Framework의 상속 기본 구조 Java Collection Framework 각 인터페이스의 특징 List LinkedList, Stack, Vector, ArrayList 순서가 있는 데이터의 집합 데이터의 중복을 허용 Set HashSet, TreeSet 순서를 유지하지 않는 데이터의 집합 데이터의 중복을 허용하지 않…","fields":{"slug":"/2021-05-22-java-collection/"},"frontmatter":{"date":"May 22, 2021","title":"Java Collection","tags":["Java","Algorithm"]},"rawMarkdownBody":"\r\n### Java Collection Framework의 상속 기본 구조\r\n\r\n![Java Collection Framework]({{\"/assets/images/java-collection.png\"| relative_url}})\r\n\r\n### 각 인터페이스의 특징\r\n\r\n1. List\r\n- LinkedList, Stack, Vector, ArrayList\r\n- 순서가 있는 데이터의 집합\r\n- 데이터의 중복을 허용\r\n\r\n2. Set\r\n- HashSet, TreeSet\r\n- 순서를 유지하지 않는 데이터의 집합\r\n- 데이터의 중복을 허용하지 않음\r\n\r\n3. Map\r\n- HashMap, TreeMap, HashTable, Properties\r\n- 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합\r\n- 순서는 유지되지 않음\r\n- 키는 중복을 허용하지 않으며, 값은 중복을 허용\r\n- List와 Set 인터페이스는 모두 Collection 인터페이스를 상속 받지만, 구조상의 차이로 인해 Map 인터페이스는 별도로 정의\r\n\r\n### 메소드\r\n\r\n```java\r\n// (*)가 표시된 메소드는 선택적인 기능\r\n\r\nboolean add(E e) // 요소 추가 (*)\r\n\r\nvoid clear() // 모든 요소 제거 (*)\r\n\r\nboolean contains(Object o) // 객체 포함하는지 확인\r\n\r\nboolean equals(Object o) // 객체가 같은지를 확인\r\n\r\nboolean isEmpty() // 비어있는지 확인\r\n\r\nIterator<E> iterator() // 반복자(iterator) 반환\r\n\r\nboolean remove(Object o) // 객체 제거 (*)\r\n\r\nint size() // 요소의 총 개수 반환\r\n\r\nObject[] toArray() // 모든 요소를 Object 타입의 배열로 반환\r\n```\r\n\r\n### 출처\r\n- <https://hwan1001.tistory.com/10>\r\n- <http://tcpschool.com/java/java_collectionFramework_concept>\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42746 문제 설명 0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 6, 10, 2라면 6102, 6210, 1062, 1026, 2610, 2106를 만들 수 있고, 이중 가…","fields":{"slug":"/2021-05-21-algorithm-programmers-17/"},"frontmatter":{"date":"May 21, 2021","title":"[프로그래머스] 가장 큰 수","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42746>\r\n\r\n### 문제 설명\r\n\r\n0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.\r\n\r\n예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.\r\n\r\n0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한 사항\r\n\r\n- numbers의 길이는 1 이상 100,000 이하입니다.\r\n- numbers의 원소는 0 이상 1,000 이하입니다.\r\n- 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.\r\n\r\n### 입출력 예\r\n\r\n|numbers|return|\r\n|-|-|\r\n|[6, 10, 12]|\"6210\"|\r\n|[3, 30, 34, 5, 9]|\"9534330\"|\r\n\r\n### 내 풀이\r\n\r\nCollections의 sort 메소드를 사용하기 위해 배열을 list에 담아 sort 메소드를 Comparator을 이용해 새로 구성한다.\r\n\r\n```java\r\nCollections.sort(list, new Comparator<String>() {\r\n    @Override\r\n    public int compare(String o1, String o2) {\r\n        return Integer.parseInt(o2 + o1) - Integer.parseInt(o1 + o2);\r\n    }\r\n});\r\n```\r\n\r\n마지막 테스트 케이스만 실패를 했는데, 이유는 numbers의 모든 원소가 0일 때 0을 출력한다는 점을 고려하지 않아 발생한 문제였다. 반례를 생각하는데 시간이 오래 걸린 문제였다.\r\n\r\n```java\r\nif (list.get(0).equals(\"0\")) return \"0\";\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public String solution(int[] numbers) {\r\n        StringBuilder sb = new StringBuilder();\r\n        List<String> list = new ArrayList<>();\r\n        for (int n : numbers) {\r\n            list.add(String.valueOf(n));\r\n        }\r\n        Collections.sort(list, new Comparator<String>() {\r\n            @Override\r\n            public int compare(String o1, String o2) {\r\n                return Integer.parseInt(o2 + o1) - Integer.parseInt(o1 + o2);\r\n            }\r\n        });\r\n        if (list.get(0).equals(\"0\")) return \"0\";\r\n        for (int i=0; i<list.size(); i++) {\r\n            sb.append(list.get(i));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42748 문제 설명 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 1, 5, 2, 6, 3, 7, 4, i = 2, j = 5, k = 3이라면 array의 2번째부터 …","fields":{"slug":"/2021-05-20-algorithm-programmers-16/"},"frontmatter":{"date":"May 20, 2021","title":"[프로그래머스] K번째수","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42748>\r\n\r\n### 문제 설명\r\n\r\n배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\r\n\r\n예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\r\n\r\n1. array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\r\n2. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\r\n3. 2에서 나온 배열의 3번째 숫자는 5입니다.\r\n\r\n배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n- array의 길이는 1 이상 100 이하입니다.\r\n- array의 각 원소는 1 이상 100 이하입니다.\r\n- commands의 길이는 1 이상 50 이하입니다.\r\n- commands의 각 원소는 길이가 3입니다.\r\n\r\n### 입출력 예\r\n\r\n|array|commands|return|\r\n|-|-|-|\r\n|[1, 5, 2, 6, 3, 7, 4]|[[2, 5, 3], [4, 4, 1], [1, 7, 3]]|[5, 6, 3]|\r\n\r\n- [1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\r\n- [1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\r\n- [1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.\r\n\r\n### 내 풀이\r\n\r\n레벨 1 문제답게 문제 주어진 그대로 구현하면 된다.\r\n\r\n1. 자르기\r\n2. 정렬하기\r\n3. index에 따른 값 담기\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int[] solution(int[] array, int[][] commands) {\r\n        int[] answer = new int[commands.length];\r\n        for (int i=0; i<commands.length; i++) {\r\n            ArrayList<Integer> list = new ArrayList<>();\r\n            for (int j=commands[i][0]-1; j<commands[i][1]; j++) {\r\n                list.add(array[j]);\r\n            }\r\n            Collections.sort(list);\r\n            answer[i] = list.get(commands[i][2] - 1);\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42628 문제 설명 이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자\t큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 …","fields":{"slug":"/2021-05-19-algorithm-programmers-15/"},"frontmatter":{"date":"May 19, 2021","title":"[프로그래머스] 이중우선순위큐","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42628>\r\n\r\n### 문제 설명\r\n\r\n이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다.\r\n\r\n|명령어|수신 탑(높이)|\r\n|-|-|\r\n|I|숫자\t큐에 주어진 숫자를 삽입합니다.|\r\n|D 1|큐에서 최댓값을 삭제합니다.|\r\n|D -1|큐에서 최솟값을 삭제합니다.|\r\n\r\n이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요.\r\n\r\n### 제한사항\r\n\r\n- operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다.\r\n- operations의 원소는 큐가 수행할 연산을 나타냅니다.\r\n    - 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다.\r\n- 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다.\r\n\r\n### 입출력 예\r\n\r\n|operations|return|\r\n|-|-|\r\n|[\"I 16\", \"D 1\"]|[0, 0]|\r\n|[\"I 7\", \"I 5\", \"I -5\", \"D -1\"]|[7, 5]|\r\n\r\n- 16을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0,0]을 반환합니다.\r\n- 7,5,-5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다.\r\n\r\n### 내 풀이\r\n\r\n최댓값과 최솟값을 출력해야 하므로\r\n1. 정렬\r\n2. 앞에서 꺼내기 (정렬하므로 최솟값은 앞에 위치)\r\n3. 뒤에서 꺼내기 (정렬하므로 최댓값은 뒤에 위치)\r\n가 필요한 자료구조로 구현해야 한다고 생각했다.\r\n\r\n하지만 우선순위 큐에서는 1번은 가능하지만, 2번과 3번은 따로 처리를 해줘야 하기 때문에 LinkedList를 사용해 삽입이 이루어질 때마다 정렬을 하기로 했다.\r\n\r\n1) I\r\n\r\n값을 삽입 후 정렬한다.\r\n\r\n```java\r\nif (c == 'I') {\r\n    list.add(i);\r\n    Collections.sort(list);\r\n}\r\n```\r\n\r\n2) D\r\n\r\n큐가 비어있으면 해당 연산을 무시하라는 제한사항이 있으므로, `!list.isEmpty()`의 조건을 넣고, 1이면 뒤에 있는 값을, -1이면 앞에 있는 값을 삭제하도록 한다.\r\n\r\n```java\r\nelse if (c == 'D' && !list.isEmpty()) {\r\n    if (i == 1) {\r\n        list.pollLast();\r\n    } else if (i == -1) {\r\n        list.pollFirst();\r\n    }\r\n}\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int[] solution(String[] operations) {\r\n        int[] answer = new int[2];\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n\r\n        for (String s : operations) {\r\n            char c = s.charAt(0);\r\n            int i = Integer.parseInt(s.substring(2));\r\n            if (c == 'I') {\r\n                list.add(i);\r\n                Collections.sort(list);\r\n            }\r\n            else if (c == 'D' && !list.isEmpty()) {\r\n                if (i == 1) {\r\n                    list.pollLast();\r\n                } else if (i == -1) {\r\n                    list.pollFirst();\r\n                }\r\n            }\r\n        }\r\n        if (!list.isEmpty()) {\r\n            answer[0] = list.peekLast();\r\n            answer[1] = list.peekFirst();\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42627 문제 설명 하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다. 예를들어 와 같은 요청이 들어왔습니다. 이를 그림으로 …","fields":{"slug":"/2021-05-18-algorithm.programmers-14/"},"frontmatter":{"date":"May 18, 2021","title":"[프로그래머스] 디스크 컨트롤러","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42627>\r\n\r\n### 문제 설명\r\n\r\n하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.\r\n\r\n예를들어\r\n```\r\n- 0ms 시점에 3ms가 소요되는 A작업 요청\r\n- 1ms 시점에 9ms가 소요되는 B작업 요청\r\n- 2ms 시점에 6ms가 소요되는 C작업 요청\r\n```\r\n와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.\r\n\r\n![문제 설명1]({{\"/assets/images/algorithm-programmers-14-1.png\"| relative_url}})\r\n\r\n한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.\r\n\r\n![문제 설명2]({{\"/assets/images/algorithm-programmers-14-2.png\"| relative_url}})\r\n\r\n```\r\n- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)\r\n- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)\r\n- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)\r\n```\r\n\r\n이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.\r\n\r\n하지만 A → C → B 순서대로 처리하면\r\n\r\n![문제 설명3]({{\"/assets/images/algorithm-programmers-14-3.png\"| relative_url}})\r\n\r\n```\r\n- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)\r\n- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)\r\n- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)\r\n이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.\r\n```\r\n\r\n각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)\r\n\r\n### 제한 사항\r\n- jobs의 길이는 1 이상 500 이하입니다.\r\n- jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.\r\n- 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.\r\n- 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.\r\n- 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.\r\n\r\n### 입출력 예\r\n\r\n|jobs|return|\r\n|-|-|\r\n|[[0, 3], [1, 9], [2, 6]]|9|\r\n\r\n- 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.\r\n- 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.\r\n- 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.\r\n\r\n### 내 풀이\r\n\r\n우선순위 큐를 이용해 큐에 작업을 넣었다가 빼면서 시간을 계산한다는 것을 토대로 문제를 풀었지만, 큐나 리스트를 작업과 대기 리스트로 나누어서 해야 된다는 점을 간과해 문제를 풀지 못했다.\r\n\r\n이 <b>[포스트](https://velog.io/@hyeon930/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-Java)</b>를 참고해 문제를 다시 풀었다.\r\n\r\n1. 대기 큐에서 요청되는 시점이 현재 시간보다 적은 경우에 작업 큐로 옮긴다.\r\n2. 작업 큐에서 소요 시간이 적은 순대로 꺼내 작업한다.\r\n3. 작업 과정\r\n    - 현재 시간에 작업이 끝나는 시간을 더한다. (작업이 종료되는 시점이 된다)\r\n    - answer에 대기 시간과 작업 시간을 더한다. (작업이 종료되는 시점 - 요청 시점)\r\n    - 종료된 작업의 수를 올린다.\r\n4. 만일 작업 큐에 아무 것도 없는 상태(대기 큐에 있는 것들 모두 요청 시점이 되지 않아 기다리는 것)라면 현재 시간을 올린다.\r\n\r\n-> 이것을 모든 작업이 끝날 때까지 반복한 후, answer에 jobs.length를 나눠 각 작업의 요청부터 종료까지 걸린 시간의 평균을 리턴한다.\r\n\r\n대기 큐와 작업 큐를 두 개 두어 대기 큐는 요청되는 시점으로, 작업 큐는 소요 시간으로 각각 오름차순 정렬한다.\r\n\r\n```java\r\nLinkedList<int[]> wait = new LinkedList<>();\r\nPriorityQueue<int[]> run = new PriorityQueue<>(new Comparator<int[]>() {\r\n    @Override\r\n    public int compare(int[] o1, int[] o2) {\r\n        return o1[1] - o2[1];\r\n    }\r\n});\r\n\r\nfor (int[] arr : jobs) wait.add(arr);\r\nCollections.sort(wait, new Comparator<int[]>() {\r\n    @Override\r\n    public int compare(int[] o1, int[] o2) {\r\n        return o1[0] - o2[0];\r\n    }\r\n});\r\n```\r\n\r\n1. 대기 큐에서 요청되는 시점이 현재 시간보다 적은 경우에 작업 큐로 옮긴다.\r\n```java\r\nwhile (!wait.isEmpty() && wait.peek()[0] <= time) {\r\n    run.add(wait.pollFirst());\r\n}\r\n```\r\n\r\n2. 작업 큐에서 소요 시간이 적은 순대로 꺼내 작업한다.\r\n```java\r\nint[] p = run.poll();\r\n```\r\n\r\n3. 작업 과정\r\n    - 현재 시간에 작업이 끝나는 시간을 더한다. (작업이 종료되는 시점이 된다)\r\n    - answer에 대기 시간과 작업 시간을 더한다. (작업이 종료되는 시점 - 요청 시점)\r\n    - 종료된 작업의 수를 올린다.\r\n```java\r\ntime += p[1];\r\nanswer += time - p[0];\r\ncount++;\r\n```\r\n\r\n4. 만일 작업 큐에 아무 것도 없는 상태(대기 큐에 있는 것들 모두 요청 시점이 되지 않아 기다리는 것)라면 현재 시간을 올린다.\r\n```java\r\nelse {\r\n    time++;\r\n}\r\n```\r\n\r\n### 전체 코드\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int[][] jobs) {\r\n        int answer = 0;\r\n        LinkedList<int[]> wait = new LinkedList<>();\r\n        PriorityQueue<int[]> run = new PriorityQueue<>(new Comparator<int[]>() {\r\n            @Override\r\n            public int compare(int[] o1, int[] o2) {\r\n                return o1[1] - o2[1];\r\n            }\r\n        });\r\n\r\n        for (int[] arr : jobs) wait.add(arr);\r\n        Collections.sort(wait, new Comparator<int[]>() {\r\n            @Override\r\n            public int compare(int[] o1, int[] o2) {\r\n                return o1[0] - o2[0];\r\n            }\r\n        });\r\n        int count = 0;\r\n        int time = wait.peek()[0];\r\n\r\n        while (count < jobs.length) {\r\n            while (!wait.isEmpty() && wait.peek()[0] <= time) {\r\n                run.add(wait.pollFirst());\r\n            }\r\n            if (!run.isEmpty()) {\r\n                int[] p = run.poll();\r\n                time += p[1];\r\n                answer += time - p[0];\r\n                count++;\r\n            } else {\r\n                time++;\r\n            }\r\n        }\r\n\r\n        return answer / jobs.length;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42626 문제 설명 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식…","fields":{"slug":"/2021-05-16-algorithm-programmers-13/"},"frontmatter":{"date":"May 16, 2021","title":"[프로그래머스] 더 맵게","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42626>\r\n\r\n### 문제 설명\r\n\r\n매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\r\n\r\n```\r\n섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)\r\n```\r\n\r\nLeo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\r\nLeo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한 사항\r\n- scoville의 길이는 2 이상 1,000,000 이하입니다.\r\n- K는 0 이상 1,000,000,000 이하입니다.\r\n- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.\r\n- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.\r\n\r\n### 입출력 예\r\n\r\n|scoville|K|return|\r\n|-|-|-|\r\n|[1, 2, 3, 9, 10, 12]|7|2|\r\n\r\n1. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\r\n    새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5 \r\n    가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\r\n\r\n2. 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\r\n    새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\r\n    가진 음식의 스코빌 지수 = [13, 9, 10, 12]\r\n\r\n모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\r\n\r\n### 내 풀이\r\n\r\n우선순위 큐를 사용하면 간단하게 풀 수 있다.\r\n\r\n예외 사항을 처리하지 못해서 시간이 걸렸는데, 역시 문제를 꼼꼼히 봐야한다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int[] scoville, int K) {\r\n        int answer = 0;\r\n        boolean flag = false;\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\r\n        for (int s : scoville) {\r\n            pq.add(s);\r\n            if (s != 0) flag = true;\r\n        }\r\n        if (!flag) return -1;\r\n        while (pq.peek() < K) {\r\n            if (pq.size() < 2) return -1;\r\n            int a = pq.poll();\r\n            int b = pq.poll();\r\n            pq.add(a + b * 2);\r\n            answer++;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42579 문제 설명 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다.\n장르 내에…","fields":{"slug":"/2021-05-15-algorithm-programmers-12/"},"frontmatter":{"date":"May 15, 2021","title":"[프로그래머스] 베스트 앨범","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42579>\r\n\r\n### 문제 설명\r\n\r\n스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.\r\n\r\n속한 노래가 많이 재생된 장르를 먼저 수록합니다.\r\n장르 내에서 많이 재생된 노래를 먼저 수록합니다.\r\n장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.\r\n노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 제한사항\r\n\r\n- genres[i]는 고유번호가 i인 노래의 장르입니다.\r\n- plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.\r\n- genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.\r\n- 장르 종류는 100개 미만입니다.\r\n- 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.\r\n- 모든 장르는 재생된 횟수가 다릅니다.\r\n\r\n### 입출력 예\r\n\r\n|genres|plays|return|\r\n|-|-|-|\r\n|[\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"]|[500, 600, 150, 800, 2500]|[4, 1, 3, 0]|\r\n\r\nclassic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다.\r\n\r\n- 고유 번호 3: 800회 재생\r\n- 고유 번호 0: 500회 재생\r\n- 고유 번호 2: 150회 재생\r\n\r\npop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다.\r\n\r\n- 고유 번호 4: 2,500회 재생\r\n- 고유 번호 1: 600회 재생\r\n\r\n따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.\r\n\r\n### 내 풀이\r\n\r\n연관되어 있는 데이터가 장르, 재생수, 인덱스 이렇게 세 개이므로 객체를 만들어준다.\r\n\r\n```java\r\npublic class Music {\r\n    String genre;\r\n    int play;\r\n    int index;\r\n\r\n    public Music(String genre, int play, int index) {\r\n        this.genre = genre;\r\n        this.play = play;\r\n        this.index = index;\r\n    }\r\n}\r\n```\r\n\r\n각 배열을 돌면서 map에 장르와 장르 당 총 재생 수를 저장한다. list는 각 객체를 저장한 리스트이다.\r\n\r\n```java\r\nMap<String, Integer> map = new HashMap<>();\r\nList<Music> list = new ArrayList<>();\r\nfor (int i=0; i<genres.length; i++) {\r\n    list.add(new Music(genres[i], plays[i], i));\r\n    if (map.containsKey(genres[i])) {\r\n        map.put(genres[i], map.get(genres[i]) + plays[i]);\r\n    } else {\r\n        map.put(genres[i], plays[i]);\r\n    }\r\n}\r\n```\r\n\r\nmap에서 총 재생수로 내림차순 정렬을 시켜 많이 재생된 장르를 먼저 수록하도록 한다.\r\nlist도 재생수 내림차순 정렬하여 노래가 재생 수대로 정렬되도록 한다.(이때 장르는 상관없이 내림차순 됨)\r\n\r\n```java\r\nList<String> keySet = new ArrayList<>(map.keySet());\r\nkeySet.sort(((o1, o2) -> map.get(o2) - map.get(o1)));\r\n\r\nCollections.sort(list, new Comparator<Music>() {\r\n    @Override\r\n    public int compare(Music o1, Music o2) {\r\n        return o2.play - o1.play;\r\n    }\r\n});\r\n```\r\n\r\nmap을 돌면서 가장 재생수의 합이 많은 장르대로 list에서 가장 높은 재생수를 가지는 두 곡의 인덱스를 answer 배열에 담는다.\r\n\r\n```java\r\nList<Integer> ans = new ArrayList<>();\r\nfor (String key : keySet) {\r\nint count = 0;\r\nfor (Music m : list) {\r\n    if (key.equals(m.genre)) {\r\n        ans.add(m.index);\r\n        count++;\r\n        if (count == 2) break;\r\n    }\r\n}\r\n}\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public class Music {\r\n        String genre;\r\n        int play;\r\n        int index;\r\n\r\n        public Music(String genre, int play, int index) {\r\n            this.genre = genre;\r\n            this.play = play;\r\n            this.index = index;\r\n        }\r\n    }\r\n    \r\n    public int[] solution(String[] genres, int[] plays) {\r\n        Map<String, Integer> map = new HashMap<>();\r\n        List<Music> list = new ArrayList<>();\r\n        for (int i=0; i<genres.length; i++) {\r\n            list.add(new Music(genres[i], plays[i], i));\r\n            if (map.containsKey(genres[i])) {\r\n                map.put(genres[i], map.get(genres[i]) + plays[i]);\r\n            } else {\r\n                map.put(genres[i], plays[i]);\r\n            }\r\n        }\r\n        List<Integer> ans = new ArrayList<>();\r\n        List<String> keySet = new ArrayList<>(map.keySet());\r\n        keySet.sort(((o1, o2) -> map.get(o2) - map.get(o1)));\r\n\r\n        Collections.sort(list, new Comparator<Music>() {\r\n            @Override\r\n            public int compare(Music o1, Music o2) {\r\n                return o2.play - o1.play;\r\n            }\r\n        });\r\n\r\n        for (String key : keySet) {\r\n            int count = 0;\r\n            for (Music m : list) {\r\n                if (key.equals(m.genre)) {\r\n                    ans.add(m.index);\r\n                    count++;\r\n                    if (count == 2) break;\r\n                }\r\n            }\r\n        }\r\n\r\n        int[] answer = new int[ans.size()];\r\n\r\n        for (int i=0; i<ans.size(); i++) {\r\n            answer[i] = ans.get(i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42578 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를…","fields":{"slug":"/2021-05-13-algorithm-programmers-11/"},"frontmatter":{"date":"May 13, 2021","title":"[프로그래머스] 위장","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42578>\r\n\r\n### 문제 설명\r\n\r\n스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\r\n\r\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\r\n\r\n|종류|이름|\r\n|-|-|\r\n|얼굴|동그란 안경, 검정 선글라스|\r\n|상의|파란색 티셔츠|\r\n|하의|청바지|\r\n|겉옷|긴 코트|\r\n\r\n스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.\r\n- 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.\r\n- 같은 이름을 가진 의상은 존재하지 않습니다.\r\n- clothes의 모든 원소는 문자열로 이루어져 있습니다.\r\n- 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '_' 로만 이루어져 있습니다.\r\n- 스파이는 하루에 최소 한 개의 의상은 입습니다.\r\n\r\n### 입출력 예\r\n\r\n|clothes|return|\r\n|-|-|\r\n|[[\"yellowhat\", \"headgear\"], [\"bluesunglasses\", \"eyewear\"], [\"green_turban\", \"headgear\"]]|5|\r\n|[[\"crowmask\", \"face\"], [\"bluesunglasses\", \"face\"], [\"smoky_makeup\", \"face\"]]|3|\r\n\r\n예제 #1\r\n\r\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\r\n\r\n```\r\n1. yellow_hat\r\n2. blue_sunglasses\r\n3. green_turban\r\n4. yellow_hat + blue_sunglasses\r\n5. green_turban + blue_sunglasses\r\n```\r\n\r\n예제 #2\r\n\r\nface에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\r\n\r\n```\r\n1. crow_mask\r\n2. blue_sunglasses\r\n3. smoky_makeup\r\n```\r\n\r\n### 내 풀이\r\n\r\n먼저 같은 종류인 것의 수를 세기 위해 종류가 key인 Map을 만들었다. Map에 있는 원소는 value에 1을 더하고, Map에 없는 원소는 value를 1로 해서 Map에 넣어준다.\r\n\r\n이후 종류의 이름은 상관없이 각각이 몇 개인지만 알면 되는데, 이후 과정에서 인덱스가 필요해서 List에 따로 저장을 했다.\r\n\r\n```java\r\nMap<String, Integer> map = new HashMap<>();\r\nfor (int i=0; i<clothes.length; i++) {\r\n    if (map.containsKey(clothes[i][1])) {\r\n        map.replace(clothes[i][1], map.get(clothes[i][1]) + 1);\r\n    } else {\r\n        map.put(clothes[i][1], 1);\r\n    }\r\n}\r\nlist = new ArrayList<>();\r\nmap.forEach((k, v) -> list.add(v));\r\n```\r\n\r\n이제 서로 다른 옷의 조합의 수를 세야 하는데, 예를 들어 list가 `[2, 1, 1, 1]` 이렇게 주어졌다면 각각이 입거나 안입거나를 선택할 수 있는데, 입는 경우의 수는 원소의 value 값이다.\r\n\r\n따라서 dfs를 이용해서 입는 경우와 안입는 경우를 선택해 탐색하는 형식으로 구현하였다.\r\n\r\n```java\r\npublic void dfs(int i, int result) {\r\n    if (i >= list.size()) {\r\n        answer += result;\r\n        return;\r\n    }\r\n    dfs(i + 1, result * list.get(i));\r\n    dfs(i + 1, result);\r\n}\r\n```\r\n\r\n문제의 조건에서 스파이는 하루에 최소 한 개의 의상은 입기 때문에 아무것도 입지 않는 경우는 빼야한다. 그래서 solution 함수 마지막에 `return answer - 1;`로 해줘야 한다.\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    static List<Integer> list;\r\n    static int answer = 0;\r\n    \r\n    public int solution(String[][] clothes) {\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for (int i=0; i<clothes.length; i++) {\r\n            if (map.containsKey(clothes[i][1])) {\r\n                map.replace(clothes[i][1], map.get(clothes[i][1]) + 1);\r\n            } else {\r\n                map.put(clothes[i][1], 1);\r\n            }\r\n        }\r\n        list = new ArrayList<>();\r\n        map.forEach((k, v) -> list.add(v));\r\n        dfs(0, 1);\r\n        return answer - 1;\r\n    }\r\n    public void dfs(int i, int result) {\r\n        if (i >= list.size()) {\r\n            answer += result;\r\n            return;\r\n        }\r\n        dfs(i + 1, result * list.get(i));\r\n        dfs(i + 1, result);\r\n    }\r\n}\r\n```\r\n\r\n### 다른 사람의 풀이\r\n\r\n생각보다 더 간단하게 풀 수 있는 방법이 있었다. \r\n\r\ndfs 과정을 거치지 말고, List의 원소의 value가 N이면 안입거나, 1개 입거나, 2개 입거나, ..., N개 입거나를 선택하는 것이기 때문에 그 경우의 수는 N + 1이고, List 원소 각각을 이런 식으로 경우의 수를 구해 모두를 곱해주면 되는 방법이다.\r\n\r\n앞서 들은 예제로, value가 각각 `[2, 1, 1, 1]` 이렇게 있다면 간단하게 `3 * 2 * 2 * 2`로 계산하면 된다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(String[][] clothes) {\r\n        int answer = 1;\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for (int i=0; i<clothes.length; i++) {\r\n            if (map.containsKey(clothes[i][1])) {\r\n                map.replace(clothes[i][1],map.get(clothes[i][1]) + 1);\r\n            } else {\r\n                map.put(clothes[i][1], 1);\r\n            }\r\n        }\r\n        for (String k : map.keySet()) {\r\n            answer *= map.get(k) + 1;\r\n        }\r\n        return answer - 1;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42577 문제 설명 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.\n전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석…","fields":{"slug":"/2021-05-11-algorithm-programmers-10/"},"frontmatter":{"date":"May 11, 2021","title":"[프로그래머스] 전화번호 목록","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42577>\r\n\r\n### 문제 설명\r\n\r\n전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.\r\n전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.\r\n\r\n- 구조대 : 119\r\n- 박준영 : 97 674 223\r\n- 지영석 : 11 9552 4421\r\n\r\n전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한 사항\r\n\r\n- phone_book의 길이는 1 이상 1,000,000 이하입니다.\r\n- 각 전화번호의 길이는 1 이상 20 이하입니다.\r\n- 같은 전화번호가 중복해서 들어있지 않습니다.\r\n\r\n### 입출력 예제\r\n\r\n|phone_book|return|\r\n|-|-|\r\n|[\"119\",\"97674223\",\"1195524421\"]|false|\r\n|[\"123\",\"456\",\"789\"]|true|\r\n|[\"12\",\"123\",\"1235\",\"567\",\"88\"]|false|\r\n\r\n### 내 풀이\r\n\r\nsort를 할 경우, A가 B의 접두어가 된다면 A와 B 사이에는 접두어가 아니면 들어갈 수 없다는 것을 이용해서 문제를 풀었다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public boolean solution(String[] phone_book) {\r\n        Arrays.sort(phone_book);\r\n        for (int i=0; i<phone_book.length-1; i++) {\r\n            if (phone_book[i].length() <= phone_book[i+1].length()\r\n                    && phone_book[i].equals(phone_book[i+1].substring(0, phone_book[i].length())))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42584 문제 설명 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한 조건 prices의 각 가격은 1 이상 10,000 이…","fields":{"slug":"/2021-05-09-algorithm-programmers-9/"},"frontmatter":{"date":"May 09, 2021","title":"[프로그래머스] 주식 가격","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42584>\r\n\r\n### 문제 설명\r\n\r\n초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 제한 조건\r\n\r\n- prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.\r\n- prices의 길이는 2 이상 100,000 이하입니다.\r\n\r\n### 입출력 예\r\n\r\n|prices|return|\r\n|-|-|\r\n|[1, 2, 3, 2, 3]|[4, 3, 1, 1, 0]|\r\n\r\n- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.\r\n- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.\r\n- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.\r\n- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.\r\n- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.\r\n\r\n### 내 풀이\r\n\r\n처음에는 예제만 보고 오른쪽에서부터 min 값을 찾아서 answer 배열에 각각 `인덱스 - (min에 해당하는 인덱스)`를 하면 될 거라고 생각해서 아래와 같은 답을 도출했다.\r\n\r\n```java\r\nint minId = prices.length - 1;\r\nfor (int i=prices.length - 1; i>=0; i--) {\r\n    if (prices[i] > prices[minId]) {\r\n        answer[i] = minId - i;\r\n    } else {\r\n        minId = i;\r\n        answer[i] = prices.length - 1 - i;\r\n    }\r\n}\r\n```\r\n\r\n그러나 문제에 나와 있는 예제만 잘 실행될 뿐, 나머지 테스트 케이스는 실패했다.\r\n\r\n예를 들어 `[1, 2, 3, 2, 3, 1]`에는 답이 `[5, 4, 1, 2, 1, 0]`로 나와야 하는데, 내가 짠 코드의 경우 `[5, 4, 3, 2, 1, 0]`을 도출했다. 인덱스가 2일 경우, 2가 아닌 최솟값 1의 인덱스에서 빠지기 때문에 이러한 답이 나온 것이다.\r\n\r\n여러가지 생각해보다가 도저히 안되겠어서 다른 코드를 참고했다.\r\n\r\n한 블로그에서\r\n> 뒤에서부터 순회를 할 때 앞쪽에 자신보다 작은 숫자가 앞에 있다면 자신은 굳이 스택에 들어가지 않아도 된다는 의미\r\n\r\n라는 설명을 보고 작은 숫자를 체크하는 데에 스택을 사용해서 다시 풀어보았다.\r\n\r\nPair 객체를 이용해서 인덱스와 값을 모두 저장하고, for문을 통해서 `prices.length - 2`부터(price.length - 1에서는 값이 항상 0이므로) 자신보다 작은 가장 가까운 수를 체크한다.\r\n\r\n오른쪽에 있던 수 중 자신과 가장 가까운 값이 스택에서 먼저 꺼내지기 때문에, 스택에서 차례로 꺼내진 값 중 자신보다 값이 작으면 찾고자 하는 값이 된다.\r\n\r\n```java\r\nwhile (!stack.isEmpty()) {\r\n    if (prices[i] > stack.peek().value) {\r\n        answer[i] = stack.peek().index - i;\r\n        break;\r\n    }\r\n    stack.pop();\r\n}\r\nif (stack.isEmpty()) answer[i] = prices.length - 1 - i;\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public class Pair {\r\n        public int index, value;\r\n        \r\n        public Pair(int index, int value) {\r\n            this.index = index;\r\n            this.value = value;\r\n        }\r\n    }\r\n    \r\n    public int[] solution(int[] prices) {\r\n        int[] answer = new int[prices.length];\r\n        Stack<Pair> stack = new Stack<>();\r\n        stack.add(new Pair(prices.length-1, prices[prices.length-1]));\r\n        for (int i=prices.length - 2; i>=0; i--) {\r\n            while (!stack.isEmpty()) {\r\n                if (prices[i] > stack.peek().value) {\r\n                    answer[i] = stack.peek().index - i;\r\n                    break;\r\n                }\r\n                stack.pop();\r\n            }\r\n            if (stack.isEmpty()) answer[i] = prices.length - 1 - i;\r\n            stack.add(new Pair(i, prices[i]));\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n### 참고\r\n<https://codevang.tistory.com/313>"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42583 문제 설명 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게…","fields":{"slug":"/2021-05-08-algorithm-programmers-8/"},"frontmatter":{"date":"May 08, 2021","title":"[프로그래머스] 다리를 지나는 트럭","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"---\r\n\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42583>\r\n\r\n### 문제 설명\r\n\r\n트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.\r\n※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.\r\n\r\n예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\r\n\r\n|경과 시간|다리를 지난 트럭|다리를 건너는 트럭|대기 트럭|\r\n|-|-|-|-|\r\n|0|[]|[]|[7,4,5,6]|\r\n|1~2|[]|[7]|[4,5,6]|\r\n|3|[7]|[4]|[5,6]|\r\n|4|[7]|[4,5]|[6]|\r\n|5|[7,4]|[5]|[6]|\r\n|6~7|[7,4,5]|[6]|[]|\r\n|8|[7,4,5,6]|[]|[]|\r\n\r\n따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\r\n\r\nsolution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 제한 조건\r\n\r\n- bridge_length는 1 이상 10,000 이하입니다.\r\n- weight는 1 이상 10,000 이하입니다.\r\n- truck_weights의 길이는 1 이상 10,000 이하입니다.\r\n- 모든 트럭의 무게는 1 이상 weight 이하입니다.\r\n\r\n### 입출력 예\r\n|bridge_length|weight|truck_weights|return|\r\n|-|-|-|-|\r\n|2|10|[7,4,5,6]|8|\r\n|100|100|[10]|101|\r\n|100|100|[10,10,10,10,10,10,10,10,10,10]|110|\r\n\r\n### 내 풀이\r\n\r\n다리를 건너는 트럭의 배열을 큐에 저장하는 형식으로 문제를 풀이했다. \r\n\r\n처음에는 `bridge_length`만큼 0을 넣어서 큐가 0으로 채워진 초기 상태를 만들고, `poll()`하면서 트럭이 한 칸 씩 지나가고 새로 다리에 진입하는 트럭을 `add()` 시킨다. 이때, 무게 때문에 건널 수 없을 때에는 큐에 0을 넣어서 기다리는 것처럼 처리한다.\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public int solution(int bridge_length, int weight, int[] truck_weights) {\r\n        int answer = 0;\r\n        Queue<Integer> q = new LinkedList<>();\r\n        int index = 0;\r\n        int sum = 0;\r\n        for (int i=0; i<bridge_length; i++) {\r\n            q.add(0);\r\n        }\r\n        while (!q.isEmpty()) {\r\n            sum -= q.poll();\r\n            answer++;\r\n            if (index < truck_weights.length) {\r\n                if (sum + truck_weights[index] > weight) {\r\n                    q.add(0);\r\n                } else {\r\n                    q.add(truck_weights[index]);\r\n                    sum += truck_weights[index++];\r\n                }\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42587 문제 설명 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래…","fields":{"slug":"/2021-05-06-algorithm-programmers-7/"},"frontmatter":{"date":"May 06, 2021","title":"[프로그래머스] 프린터","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42587>\r\n\r\n### 문제 설명\r\n\r\n일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.\r\n\r\n```\r\n1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.\r\n2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.\r\n3. 그렇지 않으면 J를 인쇄합니다.\r\n```\r\n\r\n예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.\r\n\r\n내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.\r\n\r\n현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.\r\n- 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.\r\n- location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.\r\n\r\n### 입출력 예\r\n\r\n|priorities|location|return|\r\n|-|-|-|\r\n|[2, 1, 3, 2]|2|1|\r\n|[1, 1, 9, 1, 1]|0|5|\r\n\r\n예제 #1\r\n문제에 나온 예와 같습니다.\r\n\r\n예제 #2\r\n6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다.\r\n\r\n### 내 풀이\r\n\r\n앞이나 뒤에 있는 원소들을 추가, 삭제를 하거나 인덱스에 있는 원소를 얻기 위해서 List를 이용했다. 문제에서 내가 인쇄를 요청한 문서의 인덱스를 얻어야 하는데, 리스트에 넣고 빼면 고유한 인덱스가 사라지기 때문에 인덱스를 따로 저장하기 위해서 Pair 객체를 만들어서 index와 value를 저장했다.\r\n\r\n다른 사람들의 풀이를 보니 이런 방식보다는 location의 값을 조정하던데 그 방법이 더 간결하고 적합해보였다. 다음에는 이 방식으로 다시 풀어봐야겠다.\r\n\r\nList에 저장된 객체 중 가장 큰 수를 찾고, for문을 돌면서 최댓값이 나올 때까지 값을 뒤로 보낸다. 최댓값을 찾았을 때, 그 인덱스가 location과 같으면 그 때의 answer값이 답이므로 리턴한다.\r\n\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    static class Pair {\r\n        int index, value;\r\n        \r\n        public Pair(int index, int value) {\r\n            this.index = index;\r\n            this.value = value;\r\n        }\r\n    }\r\n    \r\n    public int solution(int[] priorities, int location) {\r\n        int answer = 0;\r\n        List<Pair> list = new ArrayList<Pair>();\r\n        for (int i=0; i<priorities.length; i++) {\r\n            list.add(new Pair(i, priorities[i]));\r\n        }\r\n        while (!list.isEmpty()) {\r\n            int max = 0;\r\n            for (int i=0; i<list.size(); i++) {\r\n                max = list.get(i).value > max ? list.get(i).value : max;\r\n            }\r\n            for (int i=0; i<list.size(); i++) {\r\n                Pair p = list.remove(0);\r\n                if (max != p.value) list.add(p);\r\n                else {\r\n                    answer++;\r\n                    if (p.index == location) return answer;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/42586 문제 설명 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤…","fields":{"slug":"/2021-05-05-algorithm-programmers-6/"},"frontmatter":{"date":"May 05, 2021","title":"[프로그래머스] 기능개발","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42586>\r\n\r\n### 문제 설명\r\n\r\n프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.\r\n\r\n또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.\r\n\r\n먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.\r\n\r\n### 제한 사항\r\n\r\n- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.\r\n- 작업 진도는 100 미만의 자연수입니다.\r\n- 작업 속도는 100 이하의 자연수입니다.\r\n- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. - 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\r\n\r\n### 입출력 예\r\n\r\n|progresses|speeds|return|\r\n|-|-|-|\r\n|[93, 30, 55]|[1, 30, 5]|[2, 1]|\r\n|[95, 90, 99, 99, 80, 99]|[1, 1, 1, 1, 1, 1]|[1, 3, 2]|\r\n\r\n입출력 예 #1\r\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\r\n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\r\n세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\r\n\r\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\r\n\r\n입출력 예 #2\r\n모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\r\n\r\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\r\n\r\n### 내 풀이\r\n\r\n1) 작업 일수 구하기\r\n\r\n필요한 작업 일수는 `(100 - 작업의 진도) / 작업의 속도`를 통해 구할 수 있다.\r\n그런데 작업 일수가 8.3이 나온다면 올림해 9일이 나와야 하므로 ceil 함수를 통해 올림을 시켜줘야 한다.\r\n여기서 주의해야 할 점은 int 끼리 나눈 값도 int이기 때문에 값을 올림하기 위해 분모나 분자 중 하나를 실수로 형변환을 해줘야 한다. 나도 여기서 틀려서 많이 헤맸고, 다른 사람도 이 부분에서 많이 틀린 듯 했다. \r\n\r\n```java\r\nfor (int i=0; i<progresses.length; i++) {\r\n    days[i] = (int) Math.ceil((100 - progresses[i]) / (float)speeds[i]);\r\n}\r\n```\r\n\r\n2) 배포되는 기능의 수(return 값) 구하기\r\n\r\n최댓값을 저장시키고, 최댓값을 넘어가는 순간 배포가 다음으로 넘어가기 때문에 그 전까지의 count를 세서 answer에 저장해주면 된다.\r\n\r\n```java\r\nint count = 1, max = days[0];\r\n    for (int i=1; i<days.length; i++) {\r\n        if (max < days[i]) {\r\n            queue.add(count);\r\n            count = 1;\r\n            max = days[i];\r\n        } else count++;\r\n    }\r\n    queue.add(count);\r\n```\r\n\r\n### 전체 코드\r\n\r\n```java\r\nimport java.util.Queue;\r\nimport java.util.LinkedList;\r\n\r\nclass Solution {\r\n    public int[] solution(int[] progresses, int[] speeds) {\r\n        int[] days = new int[progresses.length];\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i=0; i<progresses.length; i++) {\r\n            days[i] = (int) Math.ceil((100 - progresses[i]) / (float)speeds[i]);\r\n        }\r\n        int count = 1, max = days[0];\r\n        for (int i=1; i<days.length; i++) {\r\n            if (max < days[i]) {\r\n                queue.add(count);\r\n                count = 1;\r\n                max = days[i];\r\n            } else count++;\r\n        }\r\n        queue.add(count);\r\n        int[] answer = new int[queue.size()];\r\n        int i = 0;\r\n        while(!queue.isEmpty()) {\r\n            answer[i++] = queue.poll();\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/43164 문제 설명 주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 \"ICN\" 공항에서 출발합니다. 항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solutio…","fields":{"slug":"/2021-05-03-algorithm-programmers-5/"},"frontmatter":{"date":"May 03, 2021","title":"[프로그래머스] 여행경로","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/43164>\r\n\r\n### 문제 설명\r\n\r\n주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 \"ICN\" 공항에서 출발합니다.\r\n\r\n항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 모든 공항은 알파벳 대문자 3글자로 이루어집니다.\r\n- 주어진 공항 수는 3개 이상 10,000개 이하입니다.\r\n- tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.\r\n- 주어진 항공권은 모두 사용해야 합니다.\r\n- 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.\r\n- 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.\r\n\r\n### 입출력 예\r\n\r\n|tickets|return|\r\n|-|-|\r\n|[[\"ICN\", \"JFK\"], [\"HND\", \"IAD\"], [\"JFK\", \"HND\"]]|[\"ICN\", \"JFK\", \"HND\", \"IAD\"]|\r\n|[[\"ICN\", \"SFO\"], [\"ICN\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\", \"ICN\"], [\"ATL\",\"SFO\"]]|[\"ICN\", \"ATL\", \"ICN\", \"SFO\", \"ATL\", \"SFO\"]|\r\n\r\n### 내 풀이\r\n\r\n1) dfs 함수\r\n\r\n주어진 항공권을 모두 사용해야 하므로 항상 경로에 있는 공항의 수가 티켓의 수보다 1개 더 많아야 하기 때문에 리턴 조건을 `route.size() == tickets.length + 1`로 설정한다. 그리고 가능한 경로가 2개 이상일 경우, 조건에 의해 알파벳 순서가 앞서는 경로를 return 해야하므로 compare 함수를 통해 비교할 수 있다.\r\n\r\n주어진 항공권을 다 사용하지 않은 경우, 아직 사용하지 않았으며 다음 경로로 갈 수 있는 항공권을 선택해 dfs를 다시 돌아야한다. 다음 경로로 갈 수 있는 항공권이 여러 개 있을 수 있기 때문에 dfs가 끝나면 경로에서 빼고 갈 수 있는 다른 경로를 찾을 수 있도록 한다.\r\n\r\n```java\r\npublic void dfs(String[][] tickets, ArrayList<String> route, boolean[] chk) {\r\n    if (route.size() == tickets.length + 1) {\r\n        if (answer.length <= 0 || compare(route, answer)) { // route가 answer보다 사전순으로 앞에 있으면\r\n            answer = route.toArray(new String[0]);\r\n        }\r\n        return;\r\n    }\r\n    // dfs\r\n    for (int i=0; i< tickets.length; i++) {\r\n        if (!chk[i] && route.get(route.size() - 1).equals(tickets[i][0])) {\r\n            chk[i] = true;\r\n            route.add(tickets[i][1]);\r\n            dfs(tickets, route, chk);\r\n            route.remove(route.size() - 1);\r\n            chk[i] = false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n2) compare 함수\r\n\r\n앞에 있는 배열이 사전순으로 앞에 위치한 경우, true를 리턴, 그렇지 않으면 false를 리턴하도록 한다.\r\n\r\n```java\r\npublic boolean compare(ArrayList<String> a, String[] b) {\r\n    for (int i = 0; i < a.size(); i++) {\r\n        if (a.get(i).compareTo(b[i]) < 0) { // a가 사전순으로 앞에 있으면\r\n            return true;\r\n        } else if (a.get(i).compareTo(b[i]) > 0) { // a가 사전순으로 뒤에 있으면\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n### 전체 코드\r\n```java\r\nimport java.util.ArrayList;\r\nclass Solution {\r\n    static String[] answer;\r\n    public String[] solution(String[][] tickets) {\r\n        answer = new String[]{};\r\n        ArrayList<String> route = new ArrayList<>();\r\n        route.add(\"ICN\");\r\n        dfs(tickets, route, new boolean[tickets.length]);\r\n        return answer;\r\n    }\r\n    public void dfs(String[][] tickets, ArrayList<String> route, boolean[] chk) {\r\n        if (route.size() == tickets.length + 1) {\r\n            if (answer.length <= 0 || compare(route, answer)) { // route가 answer보다 사전순으로 앞에 있으면\r\n                answer = route.toArray(new String[0]);\r\n            }\r\n            return;\r\n        }\r\n        // dfs\r\n        for (int i=0; i< tickets.length; i++) {\r\n            if (!chk[i] && route.get(route.size() - 1).equals(tickets[i][0])) {\r\n                chk[i] = true;\r\n                route.add(tickets[i][1]);\r\n                dfs(tickets, route, chk);\r\n                route.remove(route.size() - 1);\r\n                chk[i] = false;\r\n            }\r\n        }\r\n    }\r\n    public boolean compare(ArrayList<String> a, String[] b) {\r\n        for (int i = 0; i < a.size(); i++) {\r\n            if (a.get(i).compareTo(b[i]) < 0) { // a가 사전순으로 앞에 있으면\r\n                return true;\r\n            } else if (a.get(i).compareTo(b[i]) > 0) { // a가 사전순으로 뒤에 있으면\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n```\r\n\r\n테스트 케이스 한 개가 통과를 못해서 시간이 오래 걸린 문제였다. 중복 배열을 생각하지 못해서 반례를 찾기 힘들었고, 결국 질문 페이지에 있는 반례를 가지고 문제를 해결할 수 있었다."},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/43163 문제 설명 두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다. 한 번에 한 개의 알파벳만 바꿀 수 있습니다. …","fields":{"slug":"/2021-05-01-algorithm-programmers-4/"},"frontmatter":{"date":"May 01, 2021","title":"[프로그래머스] 단어 변환","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/43163>\r\n\r\n### 문제 설명\r\n\r\n두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.\r\n\r\n1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.\r\n2. words에 있는 단어로만 변환할 수 있습니다.\r\n\r\n예를 들어 begin이 \"hit\", target가 \"cog\", words가 [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]라면 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"와 같이 4단계를 거쳐 변환할 수 있습니다.\r\n\r\n두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n- 각 단어는 알파벳 소문자로만 이루어져 있습니다.\r\n- 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.\r\n- words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.\r\n- begin과 target은 같지 않습니다.\r\n- 변환할 수 없는 경우에는 0를 return 합니다.\r\n\r\n### 입출력 예\r\n\r\n|begin|target|words|return|\r\n|-|-|-|-|\r\n|\"hit\"|\"cog\"|[\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]|4|\r\n|\"hit\"|\"cog\"|[\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]|0|\r\n\r\n### 내 풀이\r\n\r\n1. words 배열에 target이 없다면 바로 0 리턴\r\n2. i번째 문자를 뺀 나머지 문자가 동일한지 words 배열을 검사\r\n3. 나머지 문자가 동일하면 방문 처리(`chk[j] = true`) 후 다음 단계의 글자를 찾음\r\n4. 탐색 중 target과 동일한 문자가 나왔을 때 answer 처리(최솟값)\r\n\r\nanswer 처리 부분이 잘 안되어서 맞춰가며 코드를 수정하다보니 코드가 조금 번잡해진게 있는 것 같다. 조금 더 깔끔하게 코드를 작성할 수 있도록 연습해야겠다.\r\n\r\n```java\r\nclass Solution {\r\n    static int answer;\r\n    public int solution(String begin, String target, String[] words) {\r\n        answer = 0;\r\n        boolean[] chk = new boolean[words.length];\r\n\r\n        // words에 target이 있는지 확인\r\n        int flag = 0;\r\n        for (String w : words) {\r\n            if(w.equals(target)) {\r\n                flag = 1;\r\n                break;\r\n            }\r\n        }\r\n        if (flag == 0) return 0;\r\n        int ans = 0;\r\n        dfs(begin, chk, target, words, ans);\r\n        return answer;\r\n    }\r\n    \r\n    public void dfs(String str, boolean[] chk, String target, String[] words, int ans) {\r\n        if (str.equals(target)) {\r\n            answer = answer == 0 ? ans : Math.min(ans, answer);\r\n            return;\r\n        }\r\n        for (int i=0; i<str.length(); i++) {\r\n            for (int j=0; j<words.length; j++) {\r\n                if(!chk[j]) {\r\n                    String ls = (i >= 1) ? str.substring(0, i) : \"\";\r\n                    String rs = (i < str.length() - 1) ? str.substring(i + 1) : \"\";\r\n                    String lw = (i >= 1) ? words[j].substring(0, i) : \"\";\r\n                    String rw = (i < str.length() - 1) ? words[j].substring(i + 1) : \"\";\r\n                    if (ls.equals(lw) && rs.equals(rw)) {\r\n                        chk[j] = true;\r\n                        ans++;\r\n                        dfs(words[j], chk, target, words, ans);\r\n                        ans--;\r\n                        chk[j] = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```"},{"excerpt":"문제 링크\nhttps://programmers.co.kr/learn/courses/30/lessons/43162 문제 설명 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 …","fields":{"slug":"/2021-04-30-algorithm-programmers-3/"},"frontmatter":{"date":"April 30, 2021","title":"[프로그래머스] 네트워크","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제 링크\r\n> <https://programmers.co.kr/learn/courses/30/lessons/43162>\r\n\r\n### 문제 설명\r\n\r\n네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.\r\n\r\n컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.\r\n\r\n### 제한사항\r\n\r\n- 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.\r\n- 각 컴퓨터는 0부터 n-1인 정수로 표현합니다.\r\n- i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.\r\n- computer[i][i]는 항상 1입니다.\r\n\r\n### 입출력 예\r\n\r\n|n|computers|return|\r\n|:---|:---|:---|\r\n|3|[[1, 1, 0], [1, 1, 1], [0, 1, 1]]|2|\r\n|3|[[1, 1, 0], [1, 1, 1], [0, 1, 1]]|1|\r\n\r\n### 내 풀이\r\n\r\ndfs로 돌면서 같은 네트워크에 있는 컴퓨터들을 검사하고, dfs 메소드를 실행할 때마다 네트워크 개수가 늘어나는 것이기 때문에 `answer++`을 한다. \r\n컴퓨터들을 검사하기 전에 이전에 방문하지 않은 컴퓨터들만 검사해야하기 때문에 isVisit 배열을 통해 방문 여부를 저장하고, 방문하지 않은(`!isVisit[i]`) 컴퓨터들만 검사하도록 한다.\r\n\r\n```java\r\nclass Solution {\r\n    public static boolean[] isVisit;\r\n    public int solution(int n, int[][] computers) {\r\n        int answer = 0;\r\n        isVisit = new boolean[n];\r\n        \r\n        for (int i=0; i<n; i++) {\r\n            if (!isVisit[i]) {\r\n                isVisit[i] = true;\r\n                answer++;\r\n                dfs(i, n, computers);\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n    public void dfs(int j, int n, int[][] coms) {\r\n        for (int k=0; k<n; k++) {\r\n            if (!isVisit[k] && coms[j][k] == 1) {\r\n                isVisit[k] = true;\r\n                dfs(k, n, coms);\r\n            }\r\n        }\r\n    }\r\n}\r\n```"},{"excerpt":"문제\nhttps://programmers.co.kr/learn/courses/30/lessons/43165 내 풀이","fields":{"slug":"/2021-04-28-algorithm-programmers-2/"},"frontmatter":{"date":"April 28, 2021","title":"[프로그래머스] 타겟 넘버","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n> 문제\r\n> <https://programmers.co.kr/learn/courses/30/lessons/43165>\r\n\r\n### 내 풀이\r\n```java\r\nclass Solution {\r\n    public int[] array;\r\n    public int gTarget;\r\n    public int answer = 0;\r\n    \r\n    public int solution(int[] numbers, int target) {\r\n        array = numbers;\r\n        gTarget = target;\r\n        dfs(0, 0);\r\n        return answer;\r\n    }\r\n    \r\n    public void dfs(int i, int sum) {\r\n        if (i >= array.length) {\r\n            if (sum == gTarget) { \r\n                answer++;\r\n            }\r\n            return;\r\n        } else {\r\n            dfs(i + 1, sum + array[i]);\r\n            dfs(i + 1, sum - array[i]);\r\n        }\r\n    }\r\n}\r\n```"},{"excerpt":"문제\nhttps://programmers.co.kr/learn/courses/30/lessons/42576 처음에는 단순하게 participant 배열을 리스트에 추가하고, completion 배열을 리스트에서 제거하면 될 것이라고 생각했다. 내 풀이 정확도 테스트에서는 통과했지만, 효율성 테스트에서 시간 초과로 실패하였다. 다른 사람의 풀이 1 part…","fields":{"slug":"/2021-03-11-algorithm-programmers-1/"},"frontmatter":{"date":"March 11, 2021","title":"[프로그래머스] 완주하지 못한 선수","tags":["Algorithm","Programmers"]},"rawMarkdownBody":"\r\n\r\n> 문제\r\n> <https://programmers.co.kr/learn/courses/30/lessons/42576>\r\n\r\n처음에는 단순하게 participant 배열을 리스트에 추가하고, completion 배열을 리스트에서 제거하면 될 것이라고 생각했다.\r\n\r\n### 내 풀이\r\n\r\n```java\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public String solution(String[] participant, String[] completion) {\r\n        List<String> list = new ArrayList<>();\r\n        for(String p : participant) {\r\n            list.add(p);\r\n        }\r\n        for(String c : completion) {\r\n            list.remove(c);\r\n        }\r\n        String answer = list.get(0);\r\n        return answer;\r\n        \r\n    }\r\n}\r\n```\r\n정확도 테스트에서는 통과했지만, 효율성 테스트에서 시간 초과로 실패하였다.\r\n\r\n### 다른 사람의 풀이 1\r\n\r\n```java\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public String solution(String[] participant, String[] completion) {\r\n        Arrays.sort(participant);\r\n        Arrays.sort(completion);\r\n        int i = 0;\r\n        for(; i<completion.length; i++) {\r\n            if(!participant[i].equals(completion[i])) {\r\n                return participant[i];\r\n            }\r\n        }\r\n        return participant[i];\r\n    }\r\n}\r\n```\r\nparticipant와 completion의 길이가 1씩 차이난다는 것을 이용하면 간단하게 풀 수 있는 문제였다.\r\n\r\n### 다른 사람의 풀이 2\r\n\r\n```java\r\nimport java.util.HashMap;\r\n\r\nclass Solution {\r\n    public String solution(String[] participant, String[] completion) {\r\n        String answer = \"\";\r\n        HashMap<String, Integer> hm = new HashMap<>();\r\n        for (String player : participant) hm.put(player, hm.getOrDefault(player, 0) + 1);\r\n        for (String player : completion) hm.put(player, hm.get(player) - 1);\r\n\r\n        for (String key : hm.keySet()) {\r\n            if (hm.get(key) != 0){\r\n                answer = key;\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\nHashMap을 사용해 깔끔하게 풀었다. \r\ngetOrDefault 함수에 대해 처음 알게되었는데, 잊지 않도록 HashMap과 관련된 함수를 정리해 포스팅 해야겠다.\r\n\r\n### 출처\r\n[프로그래머스 코딩 테스트 연습](https://programmers.co.kr/learn/challenges)"},{"excerpt":"2021.01.21 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 6강과 7강 이어서 학습 데이터의 유효성 검사 Validation 사용해서 어노테이션으로 데이터 유효성 검사 BoardValidator.java 만들어서 validator 커스텀\nSpring Boot Validation(https://seonjulee…","fields":{"slug":"/2021-01-21-project-board-6/"},"frontmatter":{"date":"January 21, 2021","title":"게시판 프로젝트 개발 일지 - 6","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n2021.01.21 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 6강과 7강 이어서 학습\r\n\r\n1. 데이터의 유효성 검사\r\n- Validation 사용해서 어노테이션으로 데이터 유효성 검사\r\n- BoardValidator.java 만들어서 validator 커스텀\r\n<b>[Spring Boot Validation]</b>(https://seonjuleee.github.io/spring/2021/01/21/springboot-validation/)"},{"excerpt":"Validation 데이터 유효성을 검사하는 로직은 애플리케이션 전체에 분산 코드 중복이 심함 비즈니스 로직에 섞여있음 이라는 문제를 가지고 있어서 기능을 추가, 수정하기 어렵고 오류 발생 가능성도 크다. Java에서 Bean Validation이라는 데이터 유효성 검사 프레임워크를 제공하는데, 다양한 제약(Constraint)을 도메인 모델(Domain…","fields":{"slug":"/2021-01-21-springboot-validation/"},"frontmatter":{"date":"January 21, 2021","title":"Spring Boot Validation","tags":["Spring Boot"]},"rawMarkdownBody":"\r\n### Validation\r\n- 데이터 유효성을 검사하는 로직은\r\n    1. 애플리케이션 전체에 분산\r\n    2. 코드 중복이 심함\r\n    3. 비즈니스 로직에 섞여있음\r\n\r\n이라는 문제를 가지고 있어서 기능을 추가, 수정하기 어렵고 오류 발생 가능성도 크다.\r\n- Java에서 Bean Validation이라는 데이터 유효성 검사 프레임워크를 제공하는데, 다양한 제약(Constraint)을 도메인 모델(Domain Model)에 어노테이션(Annotation)으로 간단하게 정의할 수 있어서 위의 문제를 해결할 수 있다.\r\n\r\n### gradle 설정\r\n```\r\nimplementation('org.springframework.boot:spring-boot-starter-validation')\r\n```\t\r\n- `spring-boot-starter-web`을 넣었다면, Bean Validation이 포함되어 있어서 따로 추가할 필요가 없다고 한다.\r\n\r\n### 제약 설정\r\n``` java\r\n@Data\r\npublic class PersonForm {\r\n    @NotNull\r\n\t@Size(min=2, max=30)\r\n\tprivate String name;\r\n\r\n\t@NotNull\r\n\t@Min(18)\r\n\tprivate Integer age;\r\n}\r\n```\r\n- 이런 식으로 어노테이션을 이용해 도메인의 제약 설정을 할 수 있다.\r\n\r\n- `@NotNull` : null 검증\r\n- `@Min` : 최솟값 검증\r\n- `@Max` : 최댓값 검증\r\n- `@Size` : 범위 검증\r\n- `@Email` : 이메일 검증\r\n- `@AssertTrue` : true 검증\r\n\r\n- `@NotEmpty` : null이나 size가 0 검증\r\n- `@NotBlank` : null이나 whitespace 검증\r\n- `@Positive`, `@PositiveOrZero` : 숫자 검증\r\n- `@Negative`, `@NegativeOrZero` : 숫자 검증\r\n- `@Past`, `@PastOrPresent` : 날짜 검증\r\n- `@Future`, `@FutureOrPresent` : 날짜 검증\r\n\r\n### Controller\r\n```java\r\n@PostMapping(\"/\")\r\npublic String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {\r\n\r\n    if (bindingResult.hasErrors()) {\r\n        return \"form\";\r\n    }\r\n\r\n    return \"redirect:/results\";\r\n}\r\n```\r\n유효성 검사를 하려는 Entity에 `@Valid` 어노테이션을 붙이고, BindingResult를 통해 결과를 받음\r\n\r\n### Front End\r\n```html\r\n<td>Name:</td>\r\n<td><input type=\"text\" th:field=\"*{name}\" /></td>\r\n<td th:if=\"${#fields.hasErrors('name')}\" th:errors=\"*{name}\">Name\r\n```\r\n유효성 검사를 하려는 부분에 `th:if`와 `th:errors`를 통해 에러처리를 할 수 있다.\r\n\r\n### Validator\r\n- 어노테이션 만으로 유효성 검사를 하는 것은 편리하지만 자유도에 제약이 있는데, Validator로 커스텀을 할 수 있다.\r\n\r\n`org.springframework.validation.Validator`에 있는 Validator 인터페이스를 구현하면 된다.\r\n\r\n```java\r\npublic class PersonValidator implements Validator {\r\n\r\n    /**\r\n     * This Validator validates only Person instances\r\n     */\r\n    public boolean supports(Class clazz) {\r\n        return Person.class.equals(clazz);\r\n    }\r\n\r\n    public void validate(Object obj, Errors e) {\r\n        ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\");\r\n        Person p = (Person) obj;\r\n        if (p.getAge() < 0) {\r\n            e.rejectValue(\"age\", \"negativevalue\");\r\n        } else if (p.getAge() > 110) {\r\n            e.rejectValue(\"age\", \"too.darn.old\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 출처\r\n- [Validation 어디까지 해봤니?](https://meetup.toast.com/posts/223)\r\n- [Spring Boot - Validation](https://heowc.dev/2018/01/14/spring-boot-hibernate-validation/)\r\n- [Validating Form Input](https://spring.io/guides/gs/validating-form-input/)\r\n- [Validation by Using Spring’s Validator Interface](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation)"},{"excerpt":"2021.01.19 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 5강과 6강 이어서 학습 JPA로 게시판 조회 @Entity : 객체와 테이블 매핑 @Id : pk 설정 @GeneratedValue : auto increment 설정 AUTO : 기본 값. 아래 세 가지 중 한 가지로 자동 설정됨 IDENTITY …","fields":{"slug":"/2021-01-19-project-board-5/"},"frontmatter":{"date":"January 19, 2021","title":"게시판 프로젝트 개발 일지 - 5","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n2021.01.19 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 5강과 6강 이어서 학습\r\n\r\n1. JPA로 게시판 조회\r\n- @Entity : 객체와 테이블 매핑\r\n- @Id : pk 설정\r\n- @GeneratedValue : auto increment 설정\r\n    + AUTO : 기본 값. 아래 세 가지 중 한 가지로 자동 설정됨\r\n    + IDENTITY : DB 컬럼 사용. 보통 많이 사용\r\n    + SEQUENCE : DB 시퀀스 사용. 가장 성능이 좋으나 따로 만들어야해서 관리하기 복잡함\r\n    + TABLE : 테이블을 따로 만들어 저장해서 사용.\r\n\r\n2. 게시판 글쓰기 기능\r\n- BoardController에서 GET으로 모델을 새로 생성해서 form.html 파일에 넘겨주고, form.html에서 POST으로 데이터를 받아 BoardController에서 저장하도록 함\r\n- Thymeleaf 문법\r\n    + `th:object` : 객체 전달\r\n    + `th:field` : 속성 전달\r\n    + `*{...}` : 객체의 속성값 \r\n\r\n3. 게시글 수정 기능\r\n- 글쓰기와 수정 기능의 메서드를 각각 분리해서 만드는 것이 아니라 하나의 메서드에서 id값의 유무에 따라 글쓰기와 수정을 결정.\r\n- BoardController에서 @RequestParam을 통해 id를 받고, id가 null이면 글쓰기로 가고 id가 있으면 해당하는 id를 가지는 객체를 수정하도록 함."},{"excerpt":"2020.12.25 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 5강 보면서 학습 db에 board 테이블 등록 mysql 이용해서 board 테이블 등록\nboard 테이블 구조 JPA 연결하기 JPA, MySQL 연결 방법 해야할 것 JPA 문법 배우기","fields":{"slug":"/2020-12-25-project-board-4/"},"frontmatter":{"date":"December 25, 2020","title":"게시판 프로젝트 개발 일지 - 4","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n2020.12.25 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 5강 보면서 학습\r\n\r\n1. db에 board 테이블 등록\r\n- mysql 이용해서 board 테이블 등록\r\n![board 테이블 구조]({{\"/assets/images/create-db-table-board.png\"| relative_url}})\r\n\r\n2. JPA 연결하기\r\n- <b>[JPA, MySQL 연결 방법](https://seonjuleee.github.io/spring/2020/12/25/springboot-mysql-jpa/)</b>\r\n\r\n\r\n### 해야할 것\r\n- JPA 문법 배우기"},{"excerpt":"bundle.gradle application.properties 출처 Spring Boot - JPA - MySQL 연동","fields":{"slug":"/2020-12-25-springboot-mysql-jpa/"},"frontmatter":{"date":"December 25, 2020","title":"Spring Boot JPA, MySQL 연동","tags":["Spring Boot","Thymeleaf"]},"rawMarkdownBody":"\r\n### bundle.gradle\r\n```h\r\n// JPA 설정\r\nimplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\r\n// mysql 설정\r\ncompile 'mysql:mysql-connector-java'\r\n```\r\n\r\n### application.properties\r\n```yml\r\nserver.address=localhost\r\nserver.port=8080\r\n\r\n# API 호출시, SQL 문을 콘솔에 출력한다.\r\nspring.jpa.show-sql=true\r\n\r\n# DDL 정의시 데이터베이스의 고유 기능을 사용합니다.\r\n# ex) 테이블 생성, 삭제 등\r\nspring.jpa.generate-ddl=true\r\nspring.jpa.database=mysql\r\n\r\n# MySQL 설정\r\nspring.datasource.url=jdbc:mysql://localhost:3306/DBNAME?useSSL=false&characterEncoding=UTF-8&serverTimezone=UTC\r\nspring.datasource.username=db아이디\r\nspring.datasource.password=db비번\r\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n\r\n# MySQL 상세 지정\r\nspring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect\r\n```\r\n\r\n### 출처\r\n[Spring Boot - JPA - MySQL 연동](https://velog.io/@2yeseul/Spring-Boot-JPA-MySQL-%EC%97%B0%EB%8F%99)"},{"excerpt":"2020.12.23 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 4강 보면서 학습 부트스트랩 사용하여 레이아웃 생성 일단 부트스트랩 학습을 위해 그대로 영상 진행하였는데, 이후에 원하는 레이아웃으로 변경할 예정이다. 오늘 배운 내용 Thymeleaf 추가적인 문법 레이아웃에 관련된 문법을 여기에 정리했다. 해야할 …","fields":{"slug":"/2020-12-23-project-board-3/"},"frontmatter":{"date":"December 23, 2020","title":"게시판 프로젝트 개발 일지 - 3","tags":["Project","Spring Boot"]},"rawMarkdownBody":"2020.12.23 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 4강 보면서 학습\r\n\r\n1. 부트스트랩 사용하여 레이아웃 생성\r\n- 일단 부트스트랩 학습을 위해 그대로 영상 진행하였는데, 이후에 원하는 레이아웃으로 변경할 예정이다.\r\n\r\n### 오늘 배운 내용\r\n1. Thymeleaf 추가적인 문법\r\n- 레이아웃에 관련된 문법을 <b>[여기](https://seonjuleee.github.io/spring/2020/12/23/thymeleaf-fragment/)</b>에 정리했다.\r\n\r\n### 해야할 것\r\n- JPA 문법 배우기"},{"excerpt":"fragment  : 반복되는 부분을 템플릿처럼 지정해두고 여러번 사용할 수 있어서 코드를 더 간결하게 만들어 줄 수 있다. 반복되는 부분을 를 이용하여 라는 이름으로 저장해주고, 사용할 부분에 , , 를 적고 뒤에 를 입력하면 앞에서의 가 적용된다. 파라미터를 이용해 값 전달 공통된 부분은 반복되는데 그 안에서 몇 가지 변경되는 부분이 있다면, 함수처럼…","fields":{"slug":"/2020-12-23-thymeleaf-fragment/"},"frontmatter":{"date":"December 23, 2020","title":"Thymeleaf fragment","tags":["Spring Boot","Thymeleaf"]},"rawMarkdownBody":"\r\n### fragment\r\n- `th:fragment` : 반복되는 부분을 템플릿처럼 지정해두고 여러번 사용할 수 있어서 코드를 더 간결하게 만들어 줄 수 있다.\r\n\r\n```html\r\n<footer> th:fragment=\"copy\">\r\n    &copy; 2011 The Good Thymes Virtual Grocery\r\n</footer>\r\n```\r\n반복되는 부분을 `th:fragment`를 이용하여 `copy`라는 이름으로 저장해주고,\r\n\r\n```html\r\n<div th:insert=\"footer :: copy\"></div>\r\n<div th:replace=\"footer :: copy\"></div>\r\n<div th:include=\"footer :: copy\"></div>\r\n```\r\n사용할 부분에 `th:insert`, `th:replace`, `th:include`를 적고 뒤에 `footer :: copy`를 입력하면 앞에서의 `copy`가 적용된다.\r\n\r\n\r\n### 파라미터를 이용해 값 전달\r\n- 공통된 부분은 반복되는데 그 안에서 몇 가지 변경되는 부분이 있다면, 함수처럼 파라미터를 이용하면 된다.\r\n\r\n```html\r\n<div th:fragment=\"frag (onevar,twovar)\">\r\n    <p th:text=\"${onevar} + ' - ' + ${twovar}\">...</p>\r\n</div>\r\n```\r\n\r\n```html\r\n<div th:replace=\"::frag (${value1},${value2})\">...</div>\r\n<div th:replace=\"::frag (onevar=${value1},twovar=${value2})\">...</div>\r\n```\r\n\r\n### insert, replace, include 차이\r\n- `th:insert` : fragment의 태그까지 그대로 가져온다.\r\n- `th:replace` : fragment의 태그로 대체된다.\r\n- `th:include` : content의 태그 그대로 사용한다.\r\n\r\n앞에서 사용한 fragment의 예제로 보면,\r\n\r\n```html\r\n<footer> th:fragment=\"copy\">\r\n    &copy; 2011 The Good Thymes Virtual Grocery\r\n</footer>\r\n```\r\n\r\n```html\r\n<div th:insert=\"footer :: copy\"></div>\r\n<div th:replace=\"footer :: copy\"></div>\r\n<div th:include=\"footer :: copy\"></div>\r\n```\r\n이것들의 결과는 다음과 같다.\r\n\r\n```html\r\n<body>\r\n  ...\r\n  <!-- th:insert -->\r\n  <div> \r\n    <footer>\r\n      &copy; 2011 The Good Thymes Virtual Grocery\r\n    </footer>\r\n  </div>\r\n  <!-- th:replace -->\r\n  <footer>\r\n    &copy; 2011 The Good Thymes Virtual Grocery\r\n  </footer>\r\n  <!-- th:include -->\r\n  <div>\r\n    &copy; 2011 The Good Thymes Virtual Grocery\r\n  </div>\r\n</body>\r\n```\r\n\r\n### 클래스 추가\r\n- `th:classappend` : 원하는 조건에 따라 클래스를 추가시킬 수 있다.\r\n\r\n```html\r\n<tr th:each=\"prod : ${prods}\" class=\"row\" th:classappend=\"${prodStat.odd}? 'odd'\">\r\n```\r\n---\r\n### 참고\r\n[Tutorial: Using Thymeleaf](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#template-layout)"},{"excerpt":"2020.12.22 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 3강과 4강 보면서 학습 github에 등록 Intellij에 git 연동하여 springboot-board로 등록하였다. 오늘 배운 내용 thymeleaf 문법 여기에 따로 정리했다. lombok getter, setter를 따로 설정하지 않고 사용…","fields":{"slug":"/2020-12-22-project-board-2/"},"frontmatter":{"date":"December 22, 2020","title":"게시판 프로젝트 개발 일지 - 2","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n2020.12.22 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 3강과 4강 보면서 학습\r\n\r\n1. github에 등록\r\n- Intellij에 git 연동하여 springboot-board로 등록하였다.\r\n\r\n### 오늘 배운 내용\r\n1. thymeleaf 문법\r\n- <b>[여기](https://seonjuleee.github.io/spring/2020/12/22/thymeleaf-syntax/)</b>에 따로 정리했다.\r\n\r\n2. lombok\r\n- getter, setter를 따로 설정하지 않고 사용할 수 있어서 코드가 간결해진다.\r\n"},{"excerpt":"텍스트 표현  : 텍스트 표현하고자 할 때 사용  : 텍스트 안에 html 태그를 반영해서 표현해줌 결과  Hello 문자와 변수 조합  : 문자와 변수를 연결하는 연산자  : 치환 처리, 텍스트 내에 변수 값을 넣을 수 있음 → 둘의 결과는 같다 표준 표현식  : 변수  : 객체의 속성값  : 메세지  : 링크 URL  : Fragment(부분적으로 공…","fields":{"slug":"/2020-12-22-thymeleaf-syntax/"},"frontmatter":{"date":"December 22, 2020","title":"Thymeleaf 문법 정리","tags":["Spring Boot","Thymeleaf"]},"rawMarkdownBody":"\n### 텍스트 표현\n- `th:text` : 텍스트 표현하고자 할 때 사용\n- `th:utext` : 텍스트 안에 html 태그를 반영해서 표현해줌\n\n```html\n<p th:text=\"'<b>Hello</b>'\" />\n<p th:utext=\"'<b>Hello</b>'\" />\n```\n\n> 결과\n\n- `<b>Hello</b>`\n- **Hello**\n\n### 문자와 변수 조합\n- `+` : 문자와 변수를 연결하는 연산자\n- `|The name is ${name}|` : 치환 처리, 텍스트 내에 변수 값을 넣을 수 있음\n\n```html\n<p th:text=\"'Hello, '+${name}+'!'\" />\n<p th:text=\"|Hello, ${name}!|\" />\n```\n→ 둘의 결과는 같다\n\n### 표준 표현식\n- `${...}` : 변수\n- `*{...}` : 객체의 속성값\n- `#{...}` : 메세지\n- `@{...}` : 링크 URL\n- `~{...}` : Fragment(부분적으로 공통된 화면을 작업)\n\n### 반복, 조건 표현\n- `th:each` : 반복문\n- `th:switch` : switch-case문\n- `th:if` : 조건문\n- `th:unless` : 조건문의 else문\n\n### value 설정\n- `th:value` : 태그 안의 value 값 지정\n\n### 변수 설정\n- `th:with` : 변수값 지정\n\n### 객체 전달\n- `th:object` : 객체 전달\n- `th:field` : 객체의 속성 전달\n\n### 참고\n[Tutorial: Using Thymeleaf](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)\n\n[Thymeleaf 태그 레퍼런스(2.1.4 버전 기준)](https://indra818.github.io/2017/11/23/thymeleaf-tag-reference/)\n\n[Thymeleaf의 기본 문법 정리(SpringBoot)](https://chung-develop.tistory.com/5)"},{"excerpt":"2020.11.30 개발 일지 오늘 진행한 내용 유튜브 코딩의신 - Spring Boot으로 웹 출시까지 1강과 2강 보면서 학습 프로젝트 생성 board라는 이름으로 프로젝트를 생성했다. 영상에서는 maven을 사용하였는데, 이미 gradle을 배웠고 gradle이 더 편리하기 때문에 maven 대신 gradle을 사용하기로 했다. home contro…","fields":{"slug":"/2020-11-30-project-board-1/"},"frontmatter":{"date":"November 30, 2020","title":"게시판 프로젝트 개발 일지 - 1","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n2020.11.30 개발 일지\r\n\r\n### 오늘 진행한 내용\r\n- 유튜브 <b>[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/watch?v=FYkn9KOfkx0&list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)</b> 1강과 2강 보면서 학습\r\n\r\n1. 프로젝트 생성\r\n- board라는 이름으로 프로젝트를 생성했다. 영상에서는 maven을 사용하였는데, 이미 gradle을 배웠고 gradle이 더 편리하기 때문에 maven 대신 gradle을 사용하기로 했다.\r\n\r\n2. home controller와 home.html\r\n- HomeController 파일을 생성해서 home.html과 연결\r\n\r\n### 해야할 것\r\n- thymeleaf 문법 배우기 - 정리하기\r\n"},{"excerpt":"Introduction Spring Boot로 게시판 만들기 Spring을 배운지 얼마되지 않았기에 프로젝트를 통해 실력을 기르고자, 가장 간단하고 많이들 하는 게시판 프로젝트를 하게 되었다. 프로젝트를 하는 과정을 기록하고 그 과정에서 생기는 문제와 그것을 해결하는 방법 등을 개발 일지에 기록할 것이다. Technologies Java Spring Sp…","fields":{"slug":"/2020-11-29-project-board-0/"},"frontmatter":{"date":"November 29, 2020","title":"게시판 프로젝트 개발 일지 - 0","tags":["Project","Spring Boot"]},"rawMarkdownBody":"\r\n### Introduction\r\nSpring Boot로 게시판 만들기\r\n\r\nSpring을 배운지 얼마되지 않았기에 프로젝트를 통해 실력을 기르고자, 가장 간단하고 많이들 하는 게시판 프로젝트를 하게 되었다.\r\n\r\n프로젝트를 하는 과정을 기록하고 그 과정에서 생기는 문제와 그것을 해결하는 방법 등을 개발 일지에 기록할 것이다.\r\n\r\n### Technologies\r\n- Java\r\n- Spring\r\n- Spring Boot\r\n- MySQL\r\n- JPA\r\n- Git, Github\r\n- Bootstrap\r\n\r\n### References\r\n[코딩의신 - Spring Boot으로 웹 출시까지](https://www.youtube.com/playlist?list=PLPtc9qD1979DG675XufGs0-gBeb2mrona)"},{"excerpt":"백준 7576 문제 예제3처럼 익은 토마토가 여러 개 존재할 수 있고, 그것들이 먼저 익고 난 다음 하루가 지나도록 해야하기 때문에 bfs을 사용했다. 큐에 저장할 객체 만들기 입력 문제에서 주어진 조건대로 입력값들을 받는다. bfs bfs를 이용해 문제를 해결하기 위해서 단계를 설정하자면, 주어진 입력값에서 토마토가 익은 것들을 큐에 넣기 큐에 있는 값…","fields":{"slug":"/2020-11-26-baekjoon-7576/"},"frontmatter":{"date":"November 26, 2020","title":"백준 7576 - 토마토","tags":["Algorithm","Baekjoon"]},"rawMarkdownBody":"\r\n[백준 7576 문제](https://www.acmicpc.net/problem/7576)\r\n\r\n예제3처럼 익은 토마토가 여러 개 존재할 수 있고, 그것들이 먼저 익고 난 다음 하루가 지나도록 해야하기 때문에 bfs을 사용했다.\r\n\r\n### 큐에 저장할 객체 만들기\r\n\r\n```java\r\npublic static class Tomato {\r\n    private int x;\r\n    private int y;\r\n    private int day;\r\n\r\n    public Tomato(int x, int y, int day) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.day = day;\r\n    }\r\n\r\n    public int getDay() {\r\n        return day;\r\n    }\r\n\r\n    public void setDay(int day) {\r\n        this.day = day;\r\n    }\r\n\r\n    public int getX() {\r\n        return x;\r\n    }\r\n\r\n    public void setX(int x) {\r\n        this.x = x;\r\n    }\r\n\r\n    public int getY() {\r\n        return y;\r\n    }\r\n\r\n    public void setY(int y) {\r\n        this.y = y;\r\n    }\r\n}\r\n```\r\n\r\n### 입력\r\n문제에서 주어진 조건대로 입력값들을 받는다.\r\n\r\n```java \r\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\nStringTokenizer st = new StringTokenizer(br.readLine());\r\n\r\nM = Integer.parseInt(st.nextToken());\r\nN = Integer.parseInt(st.nextToken());\r\ntomatoes = new int[N][M];\r\nqueue = new LinkedList<>();\r\ndays = 0;\r\n\r\nfor(int i=0; i<N; i++) {\r\n    st = new StringTokenizer(br.readLine());\r\n    for(int j=0; j<M; j++) {\r\n        tomatoes[i][j] = Integer.parseInt(st.nextToken());\r\n    }\r\n}\r\n```\r\n\r\n### bfs\r\nbfs를 이용해 문제를 해결하기 위해서 단계를 설정하자면,\r\n1. 주어진 입력값에서 토마토가 익은 것들을 큐에 넣기\r\n2. 큐에 있는 값들이 각각 다음 익은 토마토들을 표시하기 위해 큐에서 하나씩 꺼내서 다음으로 익을 토마토들을 큐에 넣기(이 과정에서 day를 하나씩 늘리면 됨)\r\n\r\n### 전체 코드\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    static int N, M, days;\r\n    static int[][] tomatoes;\r\n    static Queue<Tomato> queue;\r\n    static int[] dirX = { -1, 1, 0, 0 };\r\n    static int[] dirY = { 0, 0, -1, 1 };\r\n\r\n    public static class Tomato {\r\n        private int x;\r\n        private int y;\r\n        private int day;\r\n\r\n        public Tomato(int x, int y, int day) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.day = day;\r\n        }\r\n\r\n        public int getDay() {\r\n            return day;\r\n        }\r\n\r\n        public void setDay(int day) {\r\n            this.day = day;\r\n        }\r\n\r\n        public int getX() {\r\n            return x;\r\n        }\r\n\r\n        public void setX(int x) {\r\n            this.x = x;\r\n        }\r\n\r\n        public int getY() {\r\n            return y;\r\n        }\r\n\r\n        public void setY(int y) {\r\n            this.y = y;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n        StringTokenizer st = new StringTokenizer(br.readLine());\r\n        // 입력\r\n        M = Integer.parseInt(st.nextToken());\r\n        N = Integer.parseInt(st.nextToken());\r\n        tomatoes = new int[N][M];\r\n        queue = new LinkedList<>();\r\n        days = 0;\r\n        for(int i=0; i<N; i++) {\r\n            st = new StringTokenizer(br.readLine());\r\n            for(int j=0; j<M; j++) {\r\n                tomatoes[i][j] = Integer.parseInt(st.nextToken());\r\n            }\r\n        }\r\n\r\n        for(int i=0; i<N; i++) {\r\n            for(int j=0; j<M; j++) {\r\n                if(tomatoes[i][j] == 1) {\r\n                    queue.add(new Tomato(j, i, 0));\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!queue.isEmpty()) {\r\n            days = queue.peek().getDay();\r\n            bfs(queue.poll());\r\n        }\r\n\r\n        for(int i=0; i<N; i++) {\r\n            for(int j=0; j<M; j++) {\r\n                if(tomatoes[i][j] == 0) {\r\n                    days = -1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        System.out.println(days);\r\n        br.close();\r\n    }\r\n\r\n    private static void bfs(Tomato tomato) {\r\n        tomatoes[tomato.getY()][tomato.getX()] = 1;\r\n        int nextLevel = tomato.getDay() + 1;\r\n        for(int i=0; i<4; i++) {\r\n            int nextX = tomato.getX() + dirX[i];\r\n            int nextY = tomato.getY() + dirY[i];\r\n            if(isPossible(nextX, nextY) && tomatoes[nextY][nextX] == 0) {\r\n                tomatoes[nextY][nextX] = 1;\r\n                queue.add(new Tomato(nextX, nextY, nextLevel));\r\n            }\r\n        }\r\n    }\r\n\r\n    private static boolean isPossible(int x, int y) {\r\n        if(x >= 0 && x < M && y >= 0 && y < N) return true;\r\n        return false;\r\n    }\r\n}\r\n```"},{"excerpt":"Optional 클래스 Optional 클래스는 복잡한 조건문 없이 null 값으로 인해 발생하는 예외 처리가 가능하다. Optional 객체 생성 메소드 예제 null을 넣었을 때 실행 결과 opt1은 null 값을 가지기 때문에 NullPointerException이 발생해  결과가 나왔고, opt2는 null 값이 아니라 빈 Optional 객체이기…","fields":{"slug":"/2020-10-27-java-optional/"},"frontmatter":{"date":"October 27, 2020","title":"Java - Optional","tags":["Java"]},"rawMarkdownBody":"\r\n### Optional 클래스\r\nOptional 클래스는 복잡한 조건문 없이 null 값으로 인해 발생하는 예외 처리가 가능하다.\r\n\r\n### Optional 객체 생성 메소드\r\n\r\n```java\r\npublic static <T> Optional<T> empty()\r\n// 비어있는 Optional 객체를 생성\r\n\r\npublic static <T> Optional<T> of(T value)\r\n// null 값이 들어가면 NullPointerException 발생\r\n\r\npublic static <T> Optional<T> ofNullable(T value)\r\n// null 값이 들어가면 비어있는 Optional 객체 반환\r\n```\r\n\r\n- 예제\r\n\r\n```java\r\nimport java.util.Optional;\r\n\r\npublic class OptionalEx {\r\n\tpublic static void main(String[] args) {\r\n\t\tOptional<String> opt1 = Optional.of(\"opt1\");\r\n\t    Optional<String> opt2 = Optional.ofNullable(\"opt2\");\r\n\t}\r\n}\r\n```\r\n- null을 넣었을 때\r\n\r\n```java\r\nimport java.util.Optional;\r\n\r\npublic class OptionalEx {\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tOptional<String> opt1 = Optional.of(null);\r\n\t\t\tSystem.out.println(opt1);\r\n\t\t} catch(NullPointerException npe) {\r\n\t\t\tSystem.out.println(\"opt1은 null\");\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tOptional<String> opt2 = Optional.ofNullable(null);\r\n\t\t\tSystem.out.println(opt2);\r\n\t\t} catch(NullPointerException npe) {\r\n\t\t\tSystem.out.println(\"opt2는 null\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n실행 결과\r\n\r\n```\r\nopt1은 null\r\nOptional.empty\r\n```\r\n>opt1은 null 값을 가지기 때문에 NullPointerException이 발생해 `opt1은 null` 결과가 나왔고, <br>opt2는 null 값이 아니라 빈 Optional 객체이기 때문에 `Optional.empty`의 결과가 나왔다.\r\n\r\n### 메소드\r\n\r\n```java\r\npublic Optional<T> filter(Predicate<? super T> predicate)\r\n// 값이 참이면 해당 필터를 통과시키고 거짓이면 통과 X\r\n\r\npublic T get()\r\n// 값을 가지고 있는 Optional이면 그 값을 반환하고, 빈 객체이면 NoSuchElementException 예외 발생\r\n\r\npublic boolean isPresent()\r\n// 값이 있으면 true, 없으면 false 반환\r\n\r\npublic void ifPresent(Consumer<? super T> consumer)\r\n// 값이 있으면 인자에 있는 함수를 수행, 없으면 수행X\r\n\r\npublic T orElse(T other)\r\n// 저장된 값이 존재하면 그 값 반환, 값이 존재하지 않으면 인수로 전달된 값을 반환\r\n\r\npublic T orElseGet(Supplier<? extends T> other)\r\n// 저장된 값이 존재하면 그 값 반환, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결과값을 반환\r\n\r\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X extends Throwable\r\n// 저장된 값이 존재하면 그 값 반환, 값이 존재하지 않으면 인수로 전달된 예외 발생\r\n```\r\n\r\n### 출처\r\n- <http://tcpschool.com/java/java_stream_optional>\r\n- <https://docs.oracle.com/javase/8/docs/api/>\r\n- <https://jdm.kr/blog/234>"},{"excerpt":"인터페이스(interface) 인터페이스는 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다. 인터페이스 선언 인터페이스의 모든 필드는 이어야 하고, 모든 메소드는 여야 한다. 하지만 이 제어자를 생략할 수 있다. 인터페이스 구현 를 이용하여 인터페이스를 구현할 수 있다.…","fields":{"slug":"/2020-10-26-java-interface/"},"frontmatter":{"date":"October 26, 2020","title":"Java - Interface","tags":["Java"]},"rawMarkdownBody":"\r\n### 인터페이스(interface)\r\n인터페이스는 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.\r\n\r\n### 인터페이스 선언\r\n```java\r\npublic interface Animal {\r\n\tpublic /*abstract*/ void cry();\r\n}\r\n```\r\n인터페이스의 모든 필드는 `public static final`이어야 하고, 모든 메소드는 `public abstract`여야 한다. 하지만 이 제어자를 생략할 수 있다.\r\n\r\n### 인터페이스 구현\r\n```java\r\nclass Cat implements Animal {\r\n\tpublic void cry() {\r\n\t\tSystem.out.println(\"야옹\");\r\n\t}\r\n}\r\n```\r\n`implements`를 이용하여 인터페이스를 구현할 수 있다.\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    Cat cat = new Cat();\r\n    \r\n    cat.cry();\r\n}\r\n```\r\n실행 결과\r\n```\r\n야옹\r\n```\r\n\r\n### 출처\r\n- <http://tcpschool.com/java/java_polymorphism_interface>"},{"excerpt":"String과 StringBuilder의 차이 String은 새로운 값을 할당할 때마다 클래스가 새로 생성하기 때문에 문자열을 더하면 더할수록 메모리에 쌓인다.\n반면에 StringBuilder는 문자열을 더하면 메모리에 append하는 방식으로 클래스를 직접 생성하지 않아도 된다.  이러한 이유 때문에 긴 문자열을 이용할 때에는 StringBuilder를…","fields":{"slug":"/2020-10-23-java-stringbuilder/"},"frontmatter":{"date":"October 23, 2020","title":"Java - StringBuilder","tags":["Java"]},"rawMarkdownBody":"\r\n### String과 StringBuilder의 차이\r\nString은 새로운 값을 할당할 때마다 클래스가 새로 생성하기 때문에 문자열을 더하면 더할수록 메모리에 쌓인다.\r\n반면에 StringBuilder는 문자열을 더하면 메모리에 append하는 방식으로 클래스를 직접 생성하지 않아도 된다. \r\n\r\n이러한 이유 때문에 긴 문자열을 이용할 때에는 StringBuilder를 사용하는 것이 성능에 더 좋다.\r\n\r\n### 사용\r\n```java\r\npublic class Main {\r\n\tpublic static void main(String[] args) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(\"a\");\r\n\t\tsb.append(\"b\");\r\n\t\tsb.append(\"c\");\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n}\r\n```\r\n### 결과\r\n```java\r\nabc\r\n```\r\n\r\n\r\n출처: <https://novemberde.github.io/2017/04/15/String_0.html>"},{"excerpt":"종류 데이터형 크기(byte) 표현 범위 논리형 boolean 1 true 또는 false 문자형 char 2 '\\u0000' ~ 'uFFFF'(16비트 유니코드 문자 데이터) 정수형 byte 1 -27 ~ 27-1(-128 ~ 127) 정수형 short 2 -215 ~ 215-1(-32,768 ~ 32,767) 정수형 int 4 -231 ~ 231-1(…","fields":{"slug":"/2020-10-22-java-data-type/"},"frontmatter":{"date":"October 22, 2020","title":"자바의 기본 자료형 종류와 저장 가능 범위","tags":["Java"]},"rawMarkdownBody":"\r\n|종류| 데이터형 | 크기<small>(byte)</small> | 표현 범위|\r\n|:---:|:---:|:---:|---|\r\n|논리형|**boolean**|1| true 또는 false |\r\n|문자형|**char**|2|'\\u0000' ~ 'uFFFF'<br><small>(16비트 유니코드 문자 데이터)</small>|\r\n|정수형|**byte**|1|-2<sup>7</sup> ~ 2<sup>7</sup>-1<br><small>(-128 ~ 127)</small>|\r\n|정수형|**short**|2|-2<sup>15</sup> ~ 2<sup>15</sup>-1<br><small>(-32,768 ~ 32,767)</small>|\r\n|정수형|**int**|4|-2<sup>31</sup> ~ 2<sup>31</sup>-1<br><small>(-2,147,483,648 ~ 2,147,483,648)</small>|\r\n|정수형|**long**|8|-2<sup>63</sup> ~ 2<sup>63</sup> - 1<br><small>(-9,223,372,036,854,775,808 <br>~ 9,223,372,036,854,775,808)</small>|\r\n\r\n\r\n출처: <https://leetaehoon.tistory.com/3>"},{"excerpt":"최대공약수(gcd, greatest common divisor) 일반적으로 최대공약수를 구하기 위해서는 소인수분해를 하고, 두 수 사이에 공통된 소수를 모두 곱하면 된다. 그런데 이 방식은 수가 커질수록 복잡해지고 시간도 오래 걸린다는 단점이 있다.  유클리드 호제법을 사용하면 더 효율적으로 최대공약수를 구할 수 있다. 유클리드 호제법 두 정수 에 대해 …","fields":{"slug":"/2020-10-23-euclidean-algorithm/"},"frontmatter":{"date":"October 22, 2020","title":"유클리드 호제법(최대공약수 구하기)","tags":["Algorithm"]},"rawMarkdownBody":"\r\n### 최대공약수(gcd, greatest common divisor)\r\n일반적으로 최대공약수를 구하기 위해서는 소인수분해를 하고, 두 수 사이에 공통된 소수를 모두 곱하면 된다. 그런데 이 방식은 수가 커질수록 복잡해지고 시간도 오래 걸린다는 단점이 있다. \r\n\r\n유클리드 호제법을 사용하면 더 효율적으로 최대공약수를 구할 수 있다.\r\n\r\n### 유클리드 호제법\r\n>두 정수 $a, b(a > b)$에 대해 $a = bq + r (0 \\le r < a)$라 하면, $a, b$의 최대공약수는 $b, r$의 최대공약수와 같다.\r\n<br><br>즉, $gcd(a, b) = gcd(b, r)$\r\n\r\n\r\n### 알고리즘 구현\r\n\r\n```java\r\npublic static int gcd(int a, int b) {\r\n    int r;\r\n    while(b > 0) {\r\n        r = a % b;\r\n        a = b;\r\n        b = r;\r\n    }\r\n    return a;\r\n}\r\n\r\n```\r\n---\r\n### References\r\n\r\n[최대공약수를 구하는 쉬운 방법 — 유클리드 호제법](https://medium.com/@joongi1978/algorithm-2-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EB%A5%BC-%EA%B5%AC%ED%95%98%EB%8A%94-%EC%89%AC%EC%9A%B4-%EB%B0%A9%EB%B2%95-%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95-6ea2fa81d114)"},{"excerpt":"글꼴 변경 Google Fonts 사이트를 이용하여 쉽게 글꼴 변경이 가능하다. Google Fonts 먼저 원하는 폰트를 선택 하면 Selected family 사이드바가 나타나게 되는데, 여기서 Embed를 눌러 @import와 CSS 코드를 복사해서 파일에 붙여넣으면 된다. lanyon 테마의 경우, lanyon.css 파일에 코드를 붙여 넣으면 된…","fields":{"slug":"/2020-10-20-github-blog-custom-font/"},"frontmatter":{"date":"October 20, 2020","title":"Jekyll 테마 커스텀하기 - 글꼴 변경","tags":["Blog","Jekyll"]},"rawMarkdownBody":"\r\n### 글꼴 변경\r\nGoogle Fonts 사이트를 이용하여 쉽게 글꼴 변경이 가능하다.\r\n\r\n![Google Fonts]({{\"/assets/images/google_font.png\"| relative_url}})\r\n\r\n먼저 원하는 폰트를 선택 하면 Selected family 사이드바가 나타나게 되는데, 여기서 Embed를 눌러 @import와 CSS 코드를 복사해서 파일에 붙여넣으면 된다.\r\n\r\nlanyon 테마의 경우, lanyon.css 파일에 코드를 붙여 넣으면 된다.\r\n\r\nlanyon.css\r\n\r\n```css\r\n@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap');\r\n```\r\n\r\n```css\r\nhtml {\r\n  font-family: \"Noto Sans KR\", sans-serif, \"PT Serif\", Georgia, \"Times New Roman\", serif;\r\n}\r\n```\r\n`font-family`에 `\"Noto Sans KR\", sans-serif`를 앞부분에 추가했다."},{"excerpt":"Home 화면에서 글 제목만 보이게 설정 다른 테마는 보통 홈 화면에서 글 목록을 보여주곤 하는데, lanyon 테마는 홈 화면에서 글 전체를 전부 목록에 담아 보여줘서 다른 글을 찾기 위해서는 스크롤을 길게 내려야만 했다. 변경 전 홈 화면 상태 변경 전 홈 화면 상태 그래서 커스터마이징을 통해 홈 화면에서 글 제목만 보이도록 설정하고자 한다. inde…","fields":{"slug":"/2020-10-15-github-bolg-custom-home/"},"frontmatter":{"date":"October 15, 2020","title":"Jekyll 테마 커스텀하기 - lanyon 테마 메인 화면 변경","tags":["Blog","Jekyll"]},"rawMarkdownBody":"\r\n### Home 화면에서 글 제목만 보이게 설정\r\n\r\n다른 테마는 보통 홈 화면에서 글 목록을 보여주곤 하는데, lanyon 테마는 홈 화면에서 글 전체를 전부 목록에 담아 보여줘서 다른 글을 찾기 위해서는 스크롤을 길게 내려야만 했다.\r\n\r\n![변경 전 홈 화면 상태]({{\"/assets/images/before.png\"| relative_url}})\r\n>변경 전 홈 화면 상태\r\n\r\n그래서 커스터마이징을 통해 홈 화면에서 글 제목만 보이도록 설정하고자 한다.\r\n\r\nindex.html\r\n```html\r\n{% raw %}\r\n---\r\nlayout: default\r\ntitle: Home\r\n---\r\n\r\n<div class=\"posts\">\r\n  {% for post in paginator.posts %}\r\n  <div class=\"post\">\r\n    <h1 class=\"post-title\">\r\n      <a href=\"{{ post.url | absolute_url }}\">\r\n        {{ post.title }}\r\n      </a>\r\n    </h1>\r\n\r\n    <span class=\"post-date\">{{ post.date | date_to_string }}</span>\r\n\r\n    {{ post.content }} <!-- 이 부분을 삭제-->\r\n  </div>\r\n  {% endfor %}\r\n</div>\r\n{% endraw %}\r\n```\r\n\r\n여기서 `{% raw %}{{ post.content }}{% endraw %}`\r\n이부분을 삭제하면 글의 제목만 보여지게 된다.\r\n\r\n![변경 후 홈 화면 상태]({{\"/assets/images/after.png\"| relative_url}})\r\n>변경 후 홈 화면 상태\r\n"},{"excerpt":"2164 - 카드2","fields":{"slug":"/2020-08-04-baekjoon-2164/"},"frontmatter":{"date":"August 04, 2020","title":"백준 2164 - 카드2","tags":["Algorithm","Baekjoon"]},"rawMarkdownBody":"\r\n[2164 - 카드2](https://www.acmicpc.net/problem/2164)\r\n\r\n```java\r\nimport java.util.*;\r\npublic class Main {\r\n\tpublic static Queue<Integer> queue = new LinkedList<>();\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner scanner = new Scanner(System.in);\r\n\t\tint N = scanner.nextInt();\r\n\t\t\r\n\t\tfor(int i = 1; i <= N; i++) {\r\n\t\t\tqueue.add(i);\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i = 0; i < N; i++) {\r\n\t\t\tif(queue.size() == 1) {\r\n\t\t\t\tSystem.out.println(queue.poll());\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tqueue.poll();\r\n\t\t\tqueue.add(queue.poll());\r\n\t\t}\r\n\t}\r\n}\r\n```"},{"excerpt":"10866 - 덱","fields":{"slug":"/2020-08-04-baekjoon-10866/"},"frontmatter":{"date":"August 04, 2020","title":"백준 10866 - 덱","tags":["Algorithm","Baekjoon"]},"rawMarkdownBody":"\r\n[10866 - 덱](https://www.acmicpc.net/problem/10866)\r\n\r\n```java\r\nimport java.util.ArrayDeque;\r\nimport java.util.Deque;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n\tpublic static void main(String[] args) {\r\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\r\n\t\tScanner scan = new Scanner(System.in);\r\n\t\tint N = scan.nextInt();\r\n\t\tString str;\r\n\t\tint X;\r\n\t\t\r\n\t\tfor(int i=0; i<N; i++) {\r\n\t\t\tstr = scan.next();\r\n\t\t\tif(str.equals(\"push_front\")) {\r\n\t\t\t\tX = scan.nextInt();\r\n\t\t\t\tdeque.addFirst(X);\r\n\t\t\t} else if(str.equals(\"push_back\")) {\r\n\t\t\t\tX = scan.nextInt();\r\n\t\t\t\tdeque.addLast(X);\r\n\t\t\t} else if(str.equals(\"pop_front\"))\r\n\t\t\t\tSystem.out.println(deque.isEmpty() ? -1 : deque.removeFirst());\r\n\t\t\telse if(str.equals(\"pop_back\"))\r\n\t\t\t\tSystem.out.println(deque.isEmpty() ? -1 : deque.removeLast());\r\n\t\t\telse if(str.equals(\"size\"))\r\n\t\t\t\tSystem.out.println(deque.size());\r\n\t\t\telse if(str.equals(\"empty\")) \r\n\t\t\t\tSystem.out.println(deque.isEmpty() ? 1 : 0);\r\n\t\t\telse if(str.equals(\"front\"))\r\n\t\t\t\tSystem.out.println(deque.isEmpty() ? -1 : deque.getFirst());\r\n\t\t\telse if(str.equals(\"back\"))\r\n\t\t\t\tSystem.out.println(deque.isEmpty() ? -1 : deque.getLast());\r\n\t\t}\r\n\t}\r\n}\r\n```"},{"excerpt":"덱 Double-Ended Queue의 줄임말으로, 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생할 수 있는 큐 어떤 쪽으로 입출력 하는지에 따라서 스택(Stack)과 큐(Queue)로도 사용가능하다. 덱 생성하기 메소드 First Element(Head)  throws exception returns special value Insert void addFi…","fields":{"slug":"/2020-08-04-java-deque-class/"},"frontmatter":{"date":"August 04, 2020","title":"Java - Deque 클래스","tags":["Java"]},"rawMarkdownBody":"\r\n### 덱\r\nDouble-Ended Queue의 줄임말으로, 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생할 수 있는 큐\r\n\r\n어떤 쪽으로 입출력 하는지에 따라서 스택(Stack)과 큐(Queue)로도 사용가능하다.\r\n\r\n### 덱 생성하기\r\n```java\r\nDeque<Integer> deque = new ArrayDeque<Integer>();\r\nDeque<Integer> deque = new LinkedList<Integer>();\r\n```\r\n\r\n### 메소드\r\n* First Element(Head)\r\n\r\n|   | throws exception | returns special value |\r\n|-----|-----|-----|\r\n| Insert | void addFirst(e) | boolean offerFirst(e) |\r\n| Remove | E removeFirst() | E pollFirst() |\r\n| Examine | E getFirst() | E peekFirst() |\r\n\r\n* Last Element(Tail)\r\n\r\n|   | throws exception | returns special value |\r\n|-----|-----|-----|\r\n| Insert | void addLast(e) | boolean offerLast(e) |\r\n| Remove | E removeLast() | E pollLast() |\r\n| Examine | E getLast() | E peekLast() |\r\n\r\n\r\n* 큐처럼 사용하는 메소드\r\n\r\n```java\r\npublic boolean add(Element e)\r\n// addLast()와 동일\r\n\r\npublic boolean offer(Element e)\r\n// offerLast()와 동일\r\n\r\npublic Element remove()\r\n// removeFirst()와 동일\r\n\r\npublic Element remove(Object o)\r\n// removeFirstOccurrence()와 동일\r\n\r\npublic Element poll()\r\n// pollFirst()와 동일\r\n\r\npublic Element peek()\r\n// peekFist()와 동일\r\n```\r\n\r\n* 스택처럼 사용하는 메소드\r\n\r\n```java\r\npublic void push(Element e)\r\n// addFirst()와 동일. 덱을 스택으로 사용할 때 쓰임\r\n\r\npublic Element pop()\r\n// removeFirst()와 동일. 덱을 스택으로 사용할 때 쓰임\r\n```\r\n\r\n* 기타 메소드\r\n\r\n```java\r\npublic Element element()\r\n// 덱에 있는 첫번째 element 리턴\r\n\r\npublic boolean contains(Object o)\r\n// element가 포함되어 있는지 true/false 리턴\r\n\r\npublic int size()\r\n// 덱의 element 개수를 리턴\r\n\r\npublic boolean removeFirstOccurrence(Object o)\r\n// 덱의 앞쪽에서부터 탐색하여 Object와 동일한 첫번째 element 제거\r\n\r\npublic boolean removeLastOccurrence(Object o)\r\n// 덱의 뒤쪽에서부터 탐색하여 Object와 동일한 첫번째 element 제거\r\n```\r\n\r\n\r\n* 예제\r\n```java\r\nimport java.util.LinkedList;\r\nimport java.util.Deque;\r\npublic class Deque {\r\n    public static void main(String[] args) {\r\n        Deque<Integer> deque = new LinkedList<Integer>();\r\n        deque.add(1);\r\n        deque.addFirst(2);\r\n        deque.addLast(3);\r\n        System.out.println(deque.getFirst());\r\n        System.out.println(deque.removeLast());\r\n        System.out.println(deque.size());\r\n    }\r\n}\r\n```\r\n\r\n결과\r\n```java\r\n2\r\n3\r\n2\r\n```"},{"excerpt":"큐 클래스 큐는 FIFO(First In First Out) 구조를 가지는 자료구조 큐 생성하기 메소드  throws exception returns special value Insert boolean add(e) boolean offer(e) Remove E remove() E poll() Examine E element() E peek() queue …","fields":{"slug":"/2020-08-04-java-queue-class/"},"frontmatter":{"date":"August 04, 2020","title":"Java - Queue 클래스","tags":["Java"]},"rawMarkdownBody":"\r\n### 큐 클래스\r\n- 큐는 FIFO(First In First Out) 구조를 가지는 자료구조\r\n\r\n\r\n### 큐 생성하기\r\n```java\r\nQueue<Integer> queue = new LinkedList<>();\r\n```\r\n\r\n\r\n### 메소드\r\n\r\n|   | throws exception | returns special value |\r\n|-----|-----|-----|\r\n| Insert | boolean add(e) | boolean offer(e) |\r\n| Remove | E remove() | E poll() |\r\n| Examine | E element() | E peek() |\r\n\r\nqueue 클래스의 메소드는 문제 상황에서 예외를 던지는지 아니면 값(null 또는 false)를 반환하는지에 따라 달라질 수 있다.\r\n\r\n\r\n### 예제\r\n```java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\npublic class Queue {\r\n    public static void main(String[] args) {\r\n        Queue<Integer> queue = new LinkedList<Integer>();\r\n        queue.add(1);\r\n        queue.add(2);\r\n        queue.add(3);\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue.peek());\r\n        System.out.println(queue.isEmpty());\r\n    }\r\n}\r\n```\r\n\r\n결과\r\n```java\r\n1\r\n2\r\nfalse\r\n```\r\n"},{"excerpt":"테마 선택하기 lanyon 테마를 선택했다.   소스 다운받기 소스 다운받기\n주소를 복사해 clone하거나 zip 파일 형태로 다운받으면 된다. 나는 clone을 통해 다운받았다. 소스 옮기기 다운받은 폴더로 가서 폴더 안의 파일들을 모두 복사해서 자신의 블로그 파일에 붙여넣기 한다.   _config.yml 파일 수정하기 설정 정보를 가지는 _confi…","fields":{"slug":"/2020-07-23-github-blog-theme/"},"frontmatter":{"date":"July 23, 2020","title":"blog 테마 바꾸기","tags":["Blog"]},"rawMarkdownBody":"\r\n### 테마 선택하기\r\n[lanyon 테마](https://github.com/poole/lanyon)를 선택했다.  \r\n\r\n\r\n### 소스 다운받기\r\n<!-- 이미지 수정하기 -->\r\n![소스 다운받기]({{\"/assets/images/1.png\"| relative_url}})\r\n주소를 복사해 clone하거나 zip 파일 형태로 다운받으면 된다.\r\n\r\n나는 clone을 통해 다운받았다.\r\n\r\n```bash\r\ngit clone https://github.com/poole/lanyon.git\r\n```  \r\n\r\n\r\n### 소스 옮기기\r\n다운받은 폴더로 가서 폴더 안의 파일들을 모두 복사해서 자신의 블로그 파일에 붙여넣기 한다.  \r\n\r\n\r\n### _config.yml 파일 수정하기\r\n설정 정보를 가지는 _config.yml 파일로 가서 title, url 등 블로그에 대한 정보를 수정한다.\r\n- `url: 블로그 주소`\r\n- `baseurl: ''`\r\n\r\n```\r\nurl:                 \"https://seonjuleee.github.io\"\r\nbaseurl:             ''\r\n```  \r\n\r\n\r\n### commit 후 push\r\n```bash\r\ngit add .\r\ngit commit -m \"commit message\"\r\ngit push -u origin master\r\n```\r\n  "},{"excerpt":"스택 클래스 스택은 LIFO(Last In First Out) 구조를 가지는 자료구조 util에 기본적으로 스택을 제공해주고 있다. 스택 생성하기 메소드 예제 결과","fields":{"slug":"/2020-07-23-java-stack-class/"},"frontmatter":{"date":"July 23, 2020","title":"Java - Stack 클래스","tags":["Java"]},"rawMarkdownBody":"\r\n\r\n### 스택 클래스\r\n- 스택은 LIFO(Last In First Out) 구조를 가지는 자료구조\r\n- util에 기본적으로 스택을 제공해주고 있다.\r\n\r\n\r\n### 스택 생성하기\r\n```java\r\nStack<Element> stack = new Stack<>();\r\n```\r\n\r\n\r\n### 메소드\r\n```java\r\npublic boolean empty();\r\n// stack의 값이 비었는지 확인\r\n// 비었으면 true, 아니면 false\r\n\r\npublic Element push(Element item);\r\n// 데이터 추가\r\n\r\npublic Element pop();\r\n// 최근에 추가된(Top) 데이터 삭제\r\n\r\npublic Element peek();\r\n// 최근에 추가된(Top) 데이터 조회\r\n\r\npublic int search(Object o)\r\n// 인자값으로 받은 데이터의 위치 반환\r\n```\r\n\r\n\r\n### 예제\r\n```java\r\nimport java.util.Stack;\r\npublic class Stack {\r\n    public static void main(String[] args) {\r\n        Stack<Integer> stack = new Stack<Integer>(); \r\n        stack.push(1);\r\n        stack.push(2);\r\n        stack.push(3);\r\n        System.out.println(stack.peek());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.search(1));\r\n    }\r\n}\r\n```\r\n\r\n결과\r\n```java\r\n3\r\n3\r\n2\r\n```\r\n"},{"excerpt":"10828 - 스택","fields":{"slug":"/2020-07-23-baekjoon-10828/"},"frontmatter":{"date":"July 23, 2020","title":"백준 10828 - 스택","tags":["Algorithm","Baekjoon"]},"rawMarkdownBody":"\r\n[10828 - 스택](https://www.acmicpc.net/problem/10828)\r\n\r\n```java\r\nimport java.util.Scanner;\r\nimport java.util.Stack;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Scanner scan = new Scanner(System.in);\r\n        int N = scan.nextInt();\r\n        String command;\r\n\t\t\t\tStack<Integer> stack = new Stack<Integer>();\r\n        int pushNum;\r\n        for(int i = 0; i<N; i++) {\r\n            command = scan.next();\r\n            if(command.equals(\"push\")){\r\n                pushNum = scan.nextInt();\r\n                stack.push(pushNum);\r\n            } else if(command.equals(\"pop\")) {\r\n                System.out.println(stack.isEmpty() ? -1 : stack.pop());\r\n            } else if(command.equals(\"size\")) {\r\n                System.out.println(stack.size());\r\n            } else if(command.equals(\"empty\")) {\r\n                System.out.println(stack.isEmpty() ? 1 : 0);\r\n            } else if(command.equals(\"top\")) {\r\n                System.out.println(stack.isEmpty() ? -1 : stack.peek());\r\n            }\r\n        }\r\n    }\r\n}\r\n```"}]}},"pageContext":{}},"staticQueryHashes":[]}